<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Manoo`s 技术笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Manoo`s 技术笔记">
<meta property="og:url" content="http://blog.myimy.site/index.html">
<meta property="og:site_name" content="Manoo`s 技术笔记">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Manoo`s 技术笔记">
  
    <link rel="alternate" href="/atom.xml" title="Manoo`s 技术笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Manoo`s 技术笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">总览</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.myimy.site"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-代理模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/代理模式/" class="article-date">
  <time datetime="2019-03-12T16:00:00.000Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/代理模式/">代理模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>协调调用者和被调用者，降低了系统的耦合度</li>
<li>代理对象作为客户端和目标对象之间的中介，起到了保护目标对象的作用</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>由于在客户端和真实主题之间增加了代理对象，因此会造成请求的处理速度变慢；</li>
<li>实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度。 </li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>其实就是针对优点的一些使用场景：</p>
<ol>
<li>因为安全原因需要屏蔽客户端直接访问对象。</li>
<li>在远程调用中需要使用代理类处理远程方法调用的技术细节 (如 <a href="https://blog.csdn.net/lmy86263/article/details/72594760" target="_blank" rel="noopener">RMI</a>)。</li>
<li>为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。</li>
</ol>
<blockquote>
<ol>
<li>保护代理：控制目标对象的访问，给不同用户提供不同的访问权限 </li>
<li>智能引用代理，额外操作包括耗时操作、计算访问次数等等。目的：在不影响对象类的情况下，在访问对象时进行更多的操作。</li>
<li>虚拟代理：通过使用过一个小的对象代理一个大对象。</li>
<li>远程代理：为一个对象在不同的地址空间提供局部代表。</li>
<li>防火墙代理：保护目标不让恶意用户靠近。</li>
<li>Cache代理：为结果提供临时的存储空间，以便其他客户端调用。</li>
</ol>
</blockquote>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>在系统启动时，将消耗资源最多的方法都使用代理模式分离，可以加快系统的启动速度，减少用户的等待时间。而在用户真正做查询操作时再由代理类单独去加载真实的数据库查询类，完成用户的请求。这个过程就是使用代理模式实现了延迟加载。</p>
<p>如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它的原有的位置，只要在真正需要的时候才对它进行加载。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理的本质是，在运行时动态生成代理类，这是相对于静态代理而言的。静态代理会定义一个代理类（如ClientProxy.java），通过这个代理类来调用真实类。而动态代理没有这个代理类，只需要定义一些生成规则，代理类会在运行时动态生成。</p>
<p>动态代理类使用字节码动态生成加载技术，代理类的字节码将在运行时生成并载入当前代理的ClassLoader。生成动态代理类的方法很多，如JDK自带的动态处理、CGLIB、Javassist或者ASM库。</p>
<ul>
<li>JDK 的动态代理使用简单，它内置在 JDK 中，因此不需要引入第三方 Jar 包，但相对功能比较弱。</li>
<li>CGLIB 和 Javassist 都是高级的字节码生成库，总体性能比 JDK 自带的动态代理好，而且功能十分强大。</li>
<li>ASM 是低级的字节码生成工具，使用 ASM 已经近乎于在使用 Java bytecode 编程，对开发人员要求最高，当然，也是性能最好的一种动态代理生成工具。但 ASM 的使用很繁琐，而且性能也没有数量级的提升，与 CGLIB 等高级字节码生成工具相比，ASM 程序的维护性较差，如果不是在对性能有苛刻要求的场合，还是推荐 CGLIB 或者 Javassist。</li>
</ul>
<p>动态代理的一般处理流程：</p>
<ol>
<li>【生成代理类的字节码】根据指定的回调类生成动态代理类的字节码。</li>
<li>【生成代理类】将字节码装载到ClassLoader中，完成类的加载。</li>
<li>【生成代理类的实例】生成动态类的实例，并返回该实例。</li>
</ol>
<h4 id="jdk-proxy"><a href="#jdk-proxy" class="headerlink" title="jdk proxy"></a>jdk proxy</h4><blockquote>
<p>Demo</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//被代理的接口</span><br><span class="line">public interface IDBQuery &#123;</span><br><span class="line">    String request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//被代理接口的真实实现类</span><br><span class="line">@Slf4j</span><br><span class="line">public class DBQuery implements IDBQuery &#123;</span><br><span class="line">    public DBQuery() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            log.info(&quot;get db connection...begin&quot;);</span><br><span class="line">            Thread.sleep(1000);//假设数据库连接等耗时操作</span><br><span class="line">            log.info(&quot;get db connection...end&quot;);</span><br><span class="line">        &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">            log.error(ex.getLocalizedMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String request() &#123;</span><br><span class="line">        return &quot;request string&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//负责代理类的生成</span><br><span class="line">@Slf4j</span><br><span class="line">public class DBQueryJDKHandler implements InvocationHandler &#123;</span><br><span class="line">    IDBQuery realQuery = null;//定义主题接口</span><br><span class="line"></span><br><span class="line">    public DBQueryJDKHandler(IDBQuery query) &#123;</span><br><span class="line">        this.realQuery = query;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line">        log.info(&quot;[DBQueryJDKHandler][invoke] method = &quot;, method.getName());</span><br><span class="line">        return method.invoke(realQuery, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试jdk proxy代理类</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class ProxyTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testJdkProxy() &#123;</span><br><span class="line">        IDBQuery idbProxy = (IDBQuery) Proxy.newProxyInstance(</span><br><span class="line">                ClassLoader.getSystemClassLoader(), new Class[]&#123;IDBQuery.class&#125;, new DBQueryJDKHandler(new DBQuery()));</span><br><span class="line"></span><br><span class="line">        idbProxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="cglib-proxy"><a href="#cglib-proxy" class="headerlink" title="cglib proxy"></a>cglib proxy</h4><blockquote>
<p>Demo</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//被代理的真实类</span><br><span class="line">@Slf4j</span><br><span class="line">public class Hello &#123;</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        log.info(&quot;[Hello][sayHello]...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拦截真实类的方法以生成代理类</span><br><span class="line">@Slf4j</span><br><span class="line">public class HelloInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        log.info(&quot;[HelloInterceptor][intercept]...&quot;);</span><br><span class="line">        return proxy.invokeSuper(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//封装了下cglib代理类的生成代码</span><br><span class="line">public class HelloFactory &#123;</span><br><span class="line"></span><br><span class="line">    private static HelloFactory instance;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        instance = new HelloFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HelloFactory getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Hello create() &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        //指定回调类</span><br><span class="line">        enhancer.setCallback(new HelloInterceptor());</span><br><span class="line">        //指定真实类</span><br><span class="line">        enhancer.setSuperclass(Hello.class);</span><br><span class="line">        //生成代理类的实例</span><br><span class="line">        return (Hello) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试代理类的生成</span><br><span class="line">@Test</span><br><span class="line">public void testCglibProxy() &#123;</span><br><span class="line">    Hello hello = HelloFactory.getInstance().create();</span><br><span class="line">    hello.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jdk动态代理和cglib的比较"><a href="#jdk动态代理和cglib的比较" class="headerlink" title="jdk动态代理和cglib的比较"></a>jdk动态代理和cglib的比较</h4><table>
<thead>
<tr>
<th>功能\模块</th>
<th>jdk proxy</th>
<th>cglib</th>
</tr>
</thead>
<tbody>
<tr>
<td>指定回调类</td>
<td>实现InvocationHandler的自定义handler</td>
<td>拦截器，实现MethodInterceptor的自定义interceptor</td>
</tr>
<tr>
<td>类的装载</td>
<td>利用反射<br>InvocationHandler.invoke()</td>
<td>MethodInterceptor.intercept()</td>
</tr>
<tr>
<td>生成类的实例</td>
<td>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</td>
<td>反射 Enhancer enhancer = new Enhancer();<br>enhancer.setSuperclass(真实类);<br>enhancer.setCallback(回调处理类);<br>enhancer.create();</td>
</tr>
<tr>
<td>优点</td>
<td>实现比较简单，Java原生支持的，不需要任何外部依赖</td>
<td>通过继承的方式进行代理，无论目标对象有没有实现接口都可以代理</td>
</tr>
<tr>
<td>缺点</td>
<td>基于接口，如果对象没有实现接口就懵逼了</td>
<td>无法处理final的情况</td>
</tr>
<tr>
<td>效率</td>
<td>创建对象快</td>
<td>创建之后的对象运行快</td>
</tr>
</tbody>
</table>
<p>总结下：</p>
<ol>
<li>jdkproxy生成的动态类是java.lang.reflect.Proxy的子类，所有的JDK动态代理都会继承这个类。</li>
<li><p>cglib生成的动态类是真实类的子类。所以就涉及到final的问题。</p>
<ol>
<li>final类型不能有子类，所以CGLIB不能代理final类型。</li>
<li>final方法是不能重载的，所以也不能通过CGLIB代理，遇到这种情况不会抛异常，而是会跳过final方法只代理其他方法。</li>
</ol>
</li>
<li><p>cglib做了方法访问优化，使用建立方法索引的方式避免了传统Method的方法反射调用。</p>
</li>
</ol>
<h4 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h4><p>一个开源的分析、编辑和创建 Java 字节码的类库。直接操作class文件，可以修改class文件内容。性能较ASM 差，跟cglib差不多，但是使用简单。很多开源框架都在使用它。</p>
<p>优势：</p>
<ol>
<li>比反射开销小，性能高。</li>
<li>JAVAsist性能高于反射，低于ASM</li>
</ol>
<p>怎么用可以参考：<br><a href="https://segmentfault.com/a/1190000015654823" target="_blank" rel="noopener">动态字节码操作-Javassist介绍</a><br><a href="https://www.jianshu.com/p/43424242846b" target="_blank" rel="noopener">Javassist 使用指南（一）</a></p>
<h4 id="ByteBuddy"><a href="#ByteBuddy" class="headerlink" title="ByteBuddy"></a>ByteBuddy</h4><p>Byte Buddy 是直接对字节码编程的框架。当然在速度上会优于javassist。</p>
<p>Byte Buddy 的主要侧重点在于以最少的运行时生成代码。通常，类型创建或操作不是任何程序中的常见步骤，并不会对任何长期运行的应用程序产生重大影响；特别是因为类加载或类构建（class instrumentation）是运行此类代码时最耗时且不可避免的步骤。</p>
<p>具体的效率可以参见下表（从网上扣的图，没有实测过）<br><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g12az62dkkj31ja0gc0wy.jpg" alt></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol>
<li>还有其他方式实现延迟加载吗？</li>
<li><p>为什么jdk proxy要基于接口实现？<br> 这是一种设计思路。jdk是面向接口的代理。<br> 对应JDK动态代理机制是<code>委托机制</code>，具体说动态实现接口类，在动态生成的实现类里面委托为hanlder去调用原始实现类方法。</p>
<p> 比如接口类为Abo,实现类为AboImpl,AboImpl的代理类为ProxyAoImpl ，那么ProxyAoImpl 能赋值给Abo?能够赋值给AboImpl？</p>
<p> ProxyAoImpl 是能够赋值给Abo的，因为前者间接实现了后者，但是ProxyAoImpl 不能赋值给AboImpl因为他们没有继承或者实现关系。所以回顾下自己项目中Rpc里面autowired时候都是对bo类进行的，而不是对boimpl，并且我们的boimpl类一般都是配置了事务切面被代理过的。</p>
<p> 对应Cglib则使用的<code>继承机制</code>，具体说被代理类和代理类是继承关系，所以代理类是可以赋值给被代理类的,如果被代理类有接口，那么代理类也可以赋值给接口。</p>
</li>
<li><p>jvm类加载的原理？</p>
</li>
<li>拦截器的实现原理？</li>
<li>监听器的实现原理？</li>
</ol>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/index.html" target="_blank" rel="noopener">代理模式原理及实例讲解</a><br><a href="https://blog.csdn.net/carson_ho/article/details/54910472" target="_blank" rel="noopener">代理模式（Proxy Pattern）- 最易懂的设计模式解析</a><br><a href="http://www.importnew.com/27772.html" target="_blank" rel="noopener">Java Proxy 和 CGLIB 动态代理原理</a><br><a href="https://segmentfault.com/a/1190000014909002" target="_blank" rel="noopener">Java反射机制及API使用</a><br><a href="https://blog.csdn.net/zghwaicsdn/article/details/50957474" target="_blank" rel="noopener">CGLIB介绍与原理</a><br><a href="https://www.cnkirito.moe/rpc-dynamic-proxy/" target="_blank" rel="noopener">深入理解RPC之动态代理篇</a><br><a href="https://zhuanlan.zhihu.com/p/28870960" target="_blank" rel="noopener">Java JDK代理、CGLIB、AspectJ代理分析比较</a><br><a href="https://www.jianshu.com/p/3ea4a6b57f87" target="_blank" rel="noopener">深入分析Java方法反射的实现原理</a><br><a href="https://notes.diguage.com/byte-buddy-tutorial/" target="_blank" rel="noopener">Byte Buddy 教程</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.myimy.site/2019/03/13/代理模式/" data-id="cjt894lhn002y9v006k2m63c8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-自己动手写一个简单的javaagent（总纲）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/03/自己动手写一个简单的javaagent（总纲）/" class="article-date">
  <time datetime="2019-03-02T16:00:00.000Z" itemprop="datePublished">2019-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/链路监控/">链路监控</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/03/自己动手写一个简单的javaagent（总纲）/">自己动手写一个简单的探针(总纲)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol>
<li>实现对当前容器系统参数（cpu，内存，网络）的收集，并将信息上传到服务端。</li>
<li>实现一个对代码无侵入的探针，只要应用程序启动了，就自行运转，无需应用程序进行改造。</li>
<li>实现agent的心跳检测。</li>
<li>实现根据采样率调节数据收集量。</li>
</ol>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol>
<li><p>怎么在代码无侵入的要求下运行监控程序？</p>
<ul>
<li>如果要做到无侵入，那么探针势必要与应用程序运行在一个进程里。如果探针单独部署，应用程序肯定是要做代码层面的改造与探针服务进行交互。</li>
<li>如何将探针的程序注入到应用程序里呢？利用 <a href="https://www.infoq.cn/article/javaagent-illustrated" target="_blank" rel="noopener">javaagent的Instrument</a>。</li>
</ul>
</li>
<li><p>怎么收集当前容器信息？</p>
<ul>
<li>用javaagent实现无侵入部署，在启动应用程序的同时，注入探针的代码，探针会启动一个定时器，由定时器来控制触发系统指标收集的任务。</li>
<li>同时再启动一个定时器，实现心跳机制。</li>
</ul>
</li>
</ol>
<blockquote>
<p>为什么要做心跳？因为agent是单独部署在客户端的，服务端是开发者自己能够hold住的，客户端就有点鞭长莫及。所以需要用心跳来知晓agent的运行情况。</p>
</blockquote>
<ol start="3">
<li>用什么方式上传到服务端？</li>
<li>服务端数据结构怎么设计，用什么样的DB保存数据？</li>
<li>如何实现采样率的动态调节？</li>
</ol>
<h2 id="技术准备"><a href="#技术准备" class="headerlink" title="技术准备"></a>技术准备</h2><ol>
<li><p>利用instrument agent实现探针无侵入</p>
<p> <strong>Instrument</strong></p>
<p> “java.lang.instrument”包的具体实现，依赖于JVMTI。在Java SE 5 及其后续版本当中，开发者可以在一个普通 Java 程序（带有 main 函数的 Java 类）运行时，通过 <code>- javaagent</code>参数指定一个特定的jar文件来启动 Instrumentation的代理程序。</p>
<p> Instrumentation 的最大作用，就是类定义动态改变和操作。而且指令里也可以加上一些启动参数。</p>
<blockquote>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" target="_blank" rel="noopener">怎么获取启动参数？</a></p>
</blockquote>
<p> <strong>JVMTI</strong></p>
<p> JVMTI全称 JVM Tool Interface，是 JVM 暴露出来的一些供用户扩展的接口集合。JVMTI 是基于事件驱动的，JVM 每执行到一定的逻辑就会调用一些事件的回调接口（如果有的话），这些接口可以供开发者扩展自己的逻辑。</p>
<pre><code>JVMTIAgent 其实就是一个动态库，利用 JVMTI 暴露出来的一些接口来干一些我们想做、但是正常情况下又做不到的事情。
</code></pre><p> JVMTIAgent有三个回调函数，分别是：</p>
<ul>
<li>Agent_OnLoad，启动时加载。</li>
<li>Agent_OnAttach，运行时加载，这里还需要利用java的attach原理。</li>
<li><p>Agent_OnUnload，卸载时加载。</p>
<p>个人感觉这里应该用启动时加载，因为监控程序应该是7*24小时运行，必须与被监控应用相同的生命周期。如果是运行时加载，在什么样的节点启动监控也是很难定义。</p>
</li>
</ul>
</li>
<li><p>利用Byte buddy实现了类的运行时动态加载和类的加强</p>
</li>
</ol>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><ol>
<li>加载agent配置</li>
<li>加载agent插件</li>
<li>初始化agent服务管理<ol>
<li>SPI<br>JDK内置的一种服务提供发现机制</li>
<li>动态加载BootService接口的实现类</li>
<li>插件加载、匹配和拦截</li>
</ol>
</li>
</ol>
<h2 id="agent插件体系"><a href="#agent插件体系" class="headerlink" title="agent插件体系"></a>agent插件体系</h2><ol>
<li>插件的加载<ol>
<li>自定义的类加载器AgentClassLoader </li>
<li>注册</li>
<li>动态加载</li>
</ol>
</li>
<li>插件的匹配</li>
<li>插件的拦截<ol>
<li>指定需要拦截的类：在AgentBuilder.type处，这里可以指定需要拦截的类</li>
<li>指定需要拦截的方法：在builder.method处，这里可以指定需要拦截的方法</li>
<li>将需要拦截的<a href="https://www.jianshu.com/p/fe1448bf7d31" target="_blank" rel="noopener">类重新定义加载【ByteBuddy】</a>       </li>
</ol>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>PluginFinder<br>初始化方法：遍历所有pluginDefine，并获取classMatch，放到不同的map中</p>
<h2 id="TIPS："><a href="#TIPS：" class="headerlink" title="TIPS："></a>TIPS：</h2><ol>
<li>类的加载</li>
<li>类与对象的关系</li>
<li>创建一个对象的实例</li>
</ol>
<h2 id="Agent要搞清楚以下几个问题"><a href="#Agent要搞清楚以下几个问题" class="headerlink" title="Agent要搞清楚以下几个问题"></a>Agent要搞清楚以下几个问题</h2><ol>
<li>代理的类和执行main的类是一个classloader吗？<br>是的，用的是一个类加载器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_LOADER = <span class="keyword">new</span> </span><br><span class="line">AgentClassLoader(PluginBootstrap.class.getClassLoader());</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>Instrumentation、ByteBubble、OpenTracing、Grpc</p>
</li>
<li><p>怎么知道拦截了哪些类</p>
</li>
<li><p>拦截了之后如何加强这些类</p>
</li>
<li><p><a href="https://blog.myimy.site/2019/03/01/%E9%87%87%E6%A0%B7%E7%8E%87/">采样率</a>是什么作用<br> 性能和采集效率的一个综合指标，采集率高了对客户端的CPU压力自然会上升，但是采集的数据多了，对业务使用自然是更好的。</p>
</li>
<li><p>一定要引入这么多插件的jar</p>
</li>
<li><p>怎么兼容不同版本的插件</p>
</li>
<li><p>Grpc传输和http传输的区别</p>
</li>
</ol>
<h2 id="次要问题："><a href="#次要问题：" class="headerlink" title="次要问题："></a>次要问题：</h2><ol>
<li>PluginDefine和AbstractClassEnhancePluginDefine有什么区别？</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" target="_blank" rel="noopener">Instrumentation介绍</a><br><a href="https://blog.csdn.net/fengyuzhengfan/article/details/38086743" target="_blank" rel="noopener">class类简介</a><br><a href="https://www.jianshu.com/p/32d3e108f30a" target="_blank" rel="noopener">SPI和ServiceLoader</a><br><a href="https://blog.csdn.net/github_35180164/article/details/52118286" target="_blank" rel="noopener">公用API的安全狂街-自定义注解生命周期</a><br><a href="https://wu-sheng.gitbooks.io/opentracing-io/content/" target="_blank" rel="noopener">openTracing文档</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-5things13/index.html" target="_blank" rel="noopener">用 Maven 管理项目文件周期的技巧</a><br><a href="https://blog.csdn.net/belalds/article/details/83105685" target="_blank" rel="noopener">深入理解Java ClassLoader及在 JavaAgent 中的应用</a><br><a href="https://juejin.im/post/5ac32eba5188255c313af0dd" target="_blank" rel="noopener">基于Java Instrument的Agent实现</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.myimy.site/2019/03/03/自己动手写一个简单的javaagent（总纲）/" data-id="cjt894lgl000r9v00kxo0ck1o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaagent/">javaagent</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/链路监控/">链路监控</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-自己动手写一个简单的javaagent（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/03/自己动手写一个简单的javaagent（一）/" class="article-date">
  <time datetime="2019-03-02T16:00:00.000Z" itemprop="datePublished">2019-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/链路监控/">链路监控</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/03/自己动手写一个简单的javaagent（一）/">自己动手写一个简单的探针（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol>
<li>实现一个简单的javaagent。</li>
</ol>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="Step1-搭建agent的框架，实现动态加载"><a href="#Step1-搭建agent的框架，实现动态加载" class="headerlink" title="Step1 搭建agent的框架，实现动态加载"></a>Step1 搭建agent的框架，实现动态加载</h3><blockquote>
<p>Premain.java</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Premain &#123;</span><br><span class="line"></span><br><span class="line">    public static void premain(String agentArgs, Instrumentation inst) throws ClassNotFoundException, UnmodifiableClassException &#123;</span><br><span class="line">        System.out.println(&quot;enter agent premain...&quot;);</span><br><span class="line">        inst.addTransformer(new Transformer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Transformer.java</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Transformer implements ClassFileTransformer &#123;</span><br><span class="line">    private static final Set&lt;String&gt; classNameSet = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        classNameSet.add(&quot;com.example.demo.AgentTest&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 增强类 eg:静态注入监控代码</span><br><span class="line">     *</span><br><span class="line">     * @param className 类名</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public byte[] enhanceMethod(String className) &#123;</span><br><span class="line">        //增强代码 todo</span><br><span class="line">        return new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每加载一个类都会调用？</span><br><span class="line">     *</span><br><span class="line">     * @param l</span><br><span class="line">     * @param className</span><br><span class="line">     * @param c</span><br><span class="line">     * @param pd</span><br><span class="line">     * @param b</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IllegalClassFormatException</span><br><span class="line">     */</span><br><span class="line">    public byte[] transform(ClassLoader l, String className, Class&lt;?&gt; c,</span><br><span class="line">                            ProtectionDomain pd, byte[] b) throws IllegalClassFormatException &#123;</span><br><span class="line">        //判断当前的类是否需要转换</span><br><span class="line">        String currentClassName = className.replaceAll(&quot;/&quot;, &quot;.&quot;);</span><br><span class="line">        if (!classNameSet.contains(currentClassName)) &#123; // 仅仅提升Set中含有的类</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //返回增强之后的类</span><br><span class="line">        return enhanceMethod(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pom.xml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;finalName&gt;myagent&lt;/finalName&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;archive&gt;</span><br><span class="line">                    &lt;manifestEntries&gt;</span><br><span class="line">                        &lt;Premain-Class&gt;com.manoo.agent.Premain&lt;/Premain-Class&gt;</span><br><span class="line">                    &lt;/manifestEntries&gt;</span><br><span class="line">                &lt;/archive&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>新建了一个springboot项目，在VM options里加上以下指令测试javaagent</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:/Users/mayu/Documents/mycodes/myagent/target/myagent.jar</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class TestagentApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;application main&quot;);</span><br><span class="line">        SpringApplication.run(TestagentApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启动之后发现程序有报错</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: com.manoo.agent.Premain</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">	at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:304)</span><br><span class="line">	at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:401)</span><br><span class="line">FATAL ERROR in native method: processing of -javaagent failed</span><br></pre></td></tr></table></figure>
<p>看了下myagent.jar包里是有这个类的，路径也没有问题。为什么会找不到这个类？</p>
<ol>
<li><p>猜测是类加载器的问题。<br>于是研究了下javaagent的类加载原理，发现不是classloader的问题。</p>
<blockquote>
<p>因为双亲类加载的原因，javaagent是无法获取应用程序的类，但是我这里是直接获取javaagent自己的类，所以不是classloader的问题。</p>
</blockquote>
<p> <a href="http://ifeve.com/classnotfoundexception-is-it-slowing-down-your-jvm/" target="_blank" rel="noopener">ClassNotFoundException: 真的会使你的JVM慢下来吗？</a><br> <a href="https://blog.csdn.net/belalds/article/details/83105685" target="_blank" rel="noopener">深入理解Java ClassLoader及在 JavaAgent 中的应用</a></p>
</li>
</ol>
<ol start="2">
<li><p>将<code>myagent.jar</code>解压了一下，发现确实没有<code>com.manoo.agent.Premain</code>这个类，再看看发现我的classes类是在BOOT-INF/classes 路径下了。为了方便，我是直接用Spring boot创建的项目。用了<a href="https://www.cnblogs.com/acm-bingzi/p/mavenSpringBootPlugin.html" target="_blank" rel="noopener">spring-boot-maven-plugin</a>打包，导致项目被打成了Spring boot的结构的jar包。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<p> <img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0z5u8rz00j30ve0hadji.jpg" alt="spring boot项目打包后的MANIFEST"></p>
<blockquote>
<p>后来一想如果javaagent用springboot，会不会有点太重了。目前这个javaagent功能还很简单，还不要使用框架。</p>
</blockquote>
<p> 于是把spring boot的依赖注释掉，重新编译了下myagent，拿到jar包之后解压了下，现在正常了。<br> <img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0zt6er9ncj30r007sdgr.jpg" alt="jar解压后的文件夹"></p>
<p> <img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0ztdruallj30se088q49.jpg" alt="去掉spring boot之后打包生成的MANIFEST"></p>
<p> <img src="https://ws4.sinaimg.cn/large/006tKfTcly1g10bbfa8x7j312c046ab2.jpg" alt="正常运行结果"></p>
</li>
</ol>
<h3 id="Step2-实现被监控类的增强"><a href="#Step2-实现被监控类的增强" class="headerlink" title="Step2 实现被监控类的增强"></a>Step2 实现被监控类的增强</h3><ol>
<li>判断哪些类需要被监控或者说被增强</li>
<li>怎么实现被监控类的增强<ul>
<li>javassist</li>
<li>byteBuddy<a href="https://notes.diguage.com/byte-buddy-tutorial/" target="_blank" rel="noopener">（教程）</a></li>
</ul>
</li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol>
<li>代理模式</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.myimy.site/2019/03/03/自己动手写一个简单的javaagent（一）/" data-id="cjt894lgj000m9v0004w5taxk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaagent/">javaagent</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/链路监控/">链路监控</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-分布式事务常见解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/02/分布式事务常见解决方案/" class="article-date">
  <time datetime="2019-03-01T16:00:00.000Z" itemprop="datePublished">2019-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/分布式/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/02/分布式事务常见解决方案/">分布式事务常见解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Fescar"><a href="#Fescar" class="headerlink" title="Fescar"></a>Fescar</h2><p><a href="https://github.com/alibaba/fescar/" target="_blank" rel="noopener">Fescar: Fast &amp; Easy Commit And Rollback</a><br><a href="http://os.51cto.com/art/201901/590738.htm" target="_blank" rel="noopener">关于开源分布式事务中间件Fescar的提问</a><br><a href="https://www.jianshu.com/p/82b98f037034" target="_blank" rel="noopener">FESCAR：阿里重磅开源分布式事务解决方案</a></p>
<h2 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h2><h2 id="基于消息的最终一致"><a href="#基于消息的最终一致" class="headerlink" title="基于消息的最终一致"></a>基于消息的最终一致</h2><h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><h2 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.myimy.site/2019/03/02/分布式事务常见解决方案/" data-id="cjt894lgg000g9v00asrcnyn7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/REST/">REST</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RPC/">RPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/todo/">todo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-采样率" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/01/采样率/" class="article-date">
  <time datetime="2019-02-28T16:00:00.000Z" itemprop="datePublished">2019-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/分布式/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/01/采样率/">采样率</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>采样最直接的目的有两个：减少计算量和降低描述难度。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0l49r7s3ij30k00mzwew.jpg" alt></p>
<p>在APM厂商中，普遍采用这样一种采样算法来计算Apdex（Application Performance Index）。</p>
<p>Apdex的计算公式是： Apdex ＝ ( 1 x 满意 ＋0.5 x 容忍 ＋ 0 x 失望 ) / 样本数。</p>
<p>我们套一下上面的公式： 假定样本为：小于2s的请求次数为10次，满意； 大于2s，小于8s的请求次数为20次，容忍；大于等于8s的请求次数为10次，失望。 那么得到 Apdex = ( 1 x 10 + 0.5 x 20 + 0 x 10 ) / 40 = 0.5 ，结果是Unacceptable 不能接受的，说明这次采样的这个系统就在GG 的边缘了。</p>
<p>但是Apdex公式的计算只是在一个<code>宏观上判断一个服务的综合状态</code>，如果细化的话，这个计算公式是一个加权的结果，如果有5个请求都是大于等于8s,但是其他35个都是小于2s的，那么得出的Apdex为0.875，已经是Good的状态了，但是如果这8s的5个请求是服务的主入口或者重要接口，那么这Good的表面价值就会带来巨大隐患，所以对于采样率的计算，需要对于宏观上有一套计算方案，也需要对于细节处进行探查。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/40623010" target="_blank" rel="noopener">全链路分布式跟踪系统与APM</a><br><a href="https://segmentfault.com/a/1190000007370525" target="_blank" rel="noopener">浅述APM采样与端到端</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.myimy.site/2019/03/01/采样率/" data-id="cjt894lgm000t9v006dr1tenk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/链路监控/">链路监控</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Elasticsearch运维的思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Elasticsearch运维的思考/" class="article-date">
  <time datetime="2019-02-22T16:00:00.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/elasticsearch/">elasticsearch</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/23/Elasticsearch运维的思考/">Elasticsearch运维的思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="当前的情况"><a href="#当前的情况" class="headerlink" title="当前的情况"></a>当前的情况</h2><ul>
<li><p>当前每一个租户一共会创建95个索引。</p>
</li>
<li><p>分片的设置是：indexShardsNumber=2，indexReplicasNumber=0。</p>
</li>
<li><p>集群一共有四个节点，每一个节点有60G的空间。</p>
</li>
<li><p>目前线上共有6个租户，计算下来一共是1,140个分片</p>
</li>
</ul>
<h2 id="产生了哪些问题"><a href="#产生了哪些问题" class="headerlink" title="产生了哪些问题"></a>产生了哪些问题</h2><ul>
<li><p>副本数为0，没有备份，当主分区出现故障的时候，容错缺失。</p>
</li>
<li><p>分区数设置不合理，一般情况下分区数应该是节点数的1.5——3倍（因为es的分区数设置之后再调整很麻烦，所以评估好数据规模很重要），目前有4个节点，合理的分区数应该是6-18之间。</p>
</li>
<li><p>目前节点的容量以及数量很有可能跟不上业务的发展，如果大规模推广，存储机器的成本压力很大。</p>
</li>
</ul>
<h2 id="如何解决这些问题"><a href="#如何解决这些问题" class="headerlink" title="如何解决这些问题"></a>如何解决这些问题</h2><h3 id="1-预估集群大小"><a href="#1-预估集群大小" class="headerlink" title="1. 预估集群大小"></a>1. 预估集群大小</h3><p>索引吞吐量<br>文档大小<br>搜索吞吐量<br>查询类型<br>热点索引文档数量<br>保留策略<br>响应时间需求<br>SLA 级别  </p>
<h3 id="2-优化索引设计"><a href="#2-优化索引设计" class="headerlink" title="2. 优化索引设计"></a>2. 优化索引设计</h3><h3 id="3-扩大集群容量"><a href="#3-扩大集群容量" class="headerlink" title="3. 扩大集群容量"></a>3. 扩大集群容量</h3><ul>
<li><p>数据迁移</p>
<p>  步骤1：按照新需求，创建你需要分片的索引。<br>  步骤2：<a href="https://blog.csdn.net/u013613428/article/details/78227277" target="_blank" rel="noopener">reindex迁移</a></p>
</li>
</ul>
<h2 id="解决了这些问题之后，带来的变化"><a href="#解决了这些问题之后，带来的变化" class="headerlink" title="解决了这些问题之后，带来的变化"></a>解决了这些问题之后，带来的变化</h2><h2 id="问题解决之后的思考"><a href="#问题解决之后的思考" class="headerlink" title="问题解决之后的思考"></a>问题解决之后的思考</h2><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://blog.csdn.net/alan_liuyue/article/details/79585345" target="_blank" rel="noopener">Elasticsearch之如何合理分配索引分片</a><br><a href="https://cloud.tencent.com/developer/article/1361274" target="_blank" rel="noopener">Elasticsearch最佳实践之分片使用优化</a><br><a href="http://www.cnblogs.com/richaaaard/p/5227477.html" target="_blank" rel="noopener">深入理解Shard和Lucene Index</a><br><a href="https://www.infoq.cn/article/elasticsearch-performance-tuning-practice-at-ebay" target="_blank" rel="noopener">ebay的Elasticsearch调优实践</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.myimy.site/2019/02/23/Elasticsearch运维的思考/" data-id="cjt894lg200059v00qr8cmhn0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/todo/">todo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/运维/">运维</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RPC与REST" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/18/RPC与REST/" class="article-date">
  <time datetime="2019-02-17T16:00:00.000Z" itemprop="datePublished">2019-02-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/分布式/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/18/RPC与REST/">RPC与REST理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://thyrsi.com/t6/676/1551776303x2728279033.png" alt="OSI七层协议"></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h3><p>简单地说, 也就是服务器如何向客户端提供服务.</p>
<p>常用的方法有:</p>
<ul>
<li>RPC 所谓的远程过程调用 (面向方法)</li>
<li>SOA 所谓的面向服务的架构(面向消息)</li>
<li>REST 所谓的 Representational state transfer (面向资源)</li>
</ul>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC是Remote Procedure Call的缩写，字面意思是远程过程调用。但是说白了就是从本地机器去执行服务器上的一个函数。所以说 RPC 指的是一类日常的操作，是个很宽泛的概念。</p>
<p>RPC的思想是把本地函数映射到API，也就是说一个API对应的是一个方法。比如本地有一个getAllUsers，远程也能通过某种约定的协议来调用这个getAllUsers。至于这个协议是Socket、是HTTP还是别的什么并不重要（gRPC就是基于Http2.0的RPC框架）。</p>
<p>RPC中的主体都是动作，是个动词。</p>
<p>RPC像调用本地方法一样调用远程方法，通信协议大多采用二进制方式</p>
<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>REST是Representational State Transfer的缩写，翻译过来是表现层状态转换。如果一个架构符合<a href="https://blog.csdn.net/ruojingzhang/article/details/79443329" target="_blank" rel="noopener">REST原则</a>，就称它为RESTful架构。</p>
<p>REST是一种架构风格，汲取了WWW的成功经验：无状态，以资源为中心，充分利用HTTP协议和URI协议，提供统一的接口定义，使得它作为一种设计Web服务的方法而变得流行。在某种意义上，通过强调URI和HTTP等早期Internet标准，REST是对大型应用程序服务器时代之前的Web方式的回归。</p>
<p>REST的主体都是资源，是名词。</p>
<p>REST通常是Http+json、Http+xml，常见的http api都可以称为Rest接口。</p>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol>
<li>什么是资源呢？就是我们平常上网访问的一张图片、一个文档、一个视频等。这些资源我们通过URI来定位，也就是一个URI表示一个资源。</li>
<li>面向资源是什么意思？和面向动作比较优劣点在哪里？</li>
</ol>
<h2 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h2><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p>HTTP请求往往围绕资源，而RPC的请求往往围绕一个动作。</p>
<h3 id="调用协议"><a href="#调用协议" class="headerlink" title="调用协议"></a>调用协议</h3><p>接口调用通常包含两个部分，序列化和通信协议。</p>
<ul>
<li>常见的序列化协议包括Json、Xml、Hession、Protobuf、Thrift、Text、Bytes等；
　　</li>
<li>通信比较流行的是HTTP、soap、websockect、TCP等。　</li>
</ul>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><ul>
<li><p>RPC通常基于<a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="noopener">TCP协议</a>实现，常用框架例如gRpc，Netty、Mina、Thrift。</p>
</li>
<li><p>RESTful是基于<a href="feng.com/blog/2016/08/http.html">HTTP</a>协议实现。</p>
</li>
<li><p>RPC和RESTful的差别很大程度上是使用<a href="https://www.jianshu.com/p/947a2673102a" target="_blank" rel="noopener">HTTP和TCP协议的区别</a>。</p>
</li>
</ul>
<h4 id="序列化协议"><a href="#序列化协议" class="headerlink" title="序列化协议"></a>序列化协议</h4><ul>
<li><p>HTTP通常使用Json。</p>
</li>
<li><p>RPC通常是使用RPC框架，这些RPC框架采用的序列化协议比如Protobuf、Thrift性能都高于Json或者XML。</p>
</li>
<li><p><a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html" target="_blank" rel="noopener">几种序列化协议的比较</a></p>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>Http相对更规范，更标准，更通用，无论哪种语言都支持Http协议。</p>
</li>
<li><p>RPC服务则需要客户端接口与服务端保持一致（会带来一些耦合），服务端提供一个方法，客户端通过接口直接发起调用，业务开发人员仅需要关注业务方法的调用即可，不再关注网络传输的细节，在开发上更为高效。</p>
</li>
<li><p>通常在公司内部接口调用会选择RPC，简单高效。对外开放的API通常选择REST，标准规范通用。</p>
</li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://www.cnblogs.com/mindsbook/archive/2009/11/17/web_service_RESTvsRPC.html" target="_blank" rel="noopener">Web Service实践之REST vs RPC</a><br><a href="https://zhuanlan.zhihu.com/p/44096204" target="_blank" rel="noopener">HTTP 请求和 JSON-RPC</a><br><a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html" target="_blank" rel="noopener">序列化和反序列化</a><br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP协议入门</a><br><a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="noopener">TCP协议入门</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.myimy.site/2019/02/18/RPC与REST/" data-id="cjt894lg9000a9v00m5gfqr1z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/REST/">REST</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RPC/">RPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Elasticsearch的集群节点和分区" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/13/Elasticsearch的集群节点和分区/" class="article-date">
  <time datetime="2019-02-12T16:00:00.000Z" itemprop="datePublished">2019-02-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/elasticsearch/">elasticsearch</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/13/Elasticsearch的集群节点和分区/">Elasticsearch的集群节点和分区</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在存储方面，elasticsearch可以看作一个分布式数据库。<br>每一个节点可以看作是一个库，这些节点（分库）在集群内协同工作。一个索引可以看作是库里的表。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>一个节点(node)就是一个Elasticsearch实例。</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>一个集群(cluster)由一个或多个节点组成，它们具有相同<code>cluster.name</code>，它们协同工作，分享数据和负载。当加入新的节点或者删除一个节点时，集群就会感知到并平衡数据。</p>
<p>集群中一个节点会被选举为主节点(master)，它将临时管理集群级别的一些变更，例如<strong>新建或删除索引、增加或移除节点</strong>等。主节点不参与文档级别的变更或搜索，这意味着在流量增长的时候，该主节点不会成为集群的瓶颈。任何节点都可以成为主节点。</p>
<p>做为用户，我们能够与集群中的任何节点通信，包括主节点。每一个节点都知道文档存在于哪个节点上，它们可以转发请求到相应的节点上。我们访问的节点负责收集各节点返回的数据，最后一起返回给客户端。这一切都由Elasticsearch处理。</p>
<ul>
<li>主节点是否保存数据？</li>
<li>因为节点之间存在负载均衡，所以我们访问的节点可以是集群中的任意一个节点，当我们请求一个节点时，我们需要的文档不一定在该节点上，此时该节点负责收集各节点返回的数据。如果是这样的原理，那么确实要求每一个节点都知道文档的存放位置。</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><p>为了将数据添加到Elasticsearch，我们需要索引(index)——一个存储关联数据的地方。实际上，索引只是一个用来指向一个或多个分片(shards)的“逻辑命名空间(logical namespace)”.</p>
<p>一个分片(shard)是一个最小级别“工作单元(worker unit)”,它只是保存了<strong>索引中所有数据的一部分</strong><a href="水平切分还是垂直切分？应该是垂直切分的，这样才有意义。"> ^如何切分</a>。我们的文档存储在分片中，并且在分片中被索引，但是我们的应用程序不会直接与它们通信，取而代之的是，直接与索引通信。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.myimy.site/2019/02/13/Elasticsearch的集群节点和分区/" data-id="cjt894lfy00029v00x1nf8sx0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/todo/">todo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/索引/">索引</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Elasticsearch的分布式设计原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/28/Elasticsearch的分布式设计原理/" class="article-date">
  <time datetime="2019-01-27T16:00:00.000Z" itemprop="datePublished">2019-01-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/elasticsearch/">elasticsearch</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/28/Elasticsearch的分布式设计原理/">Elasticsearch的分布式设计原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.jianshu.com/p/61dd9fb7d785" target="_blank" rel="noopener">ElasticSearch 如何保证数据一致性,实时性</a><br><a href="https://blog.csdn.net/wzdxt/article/details/50868031" target="_blank" rel="noopener">为什么ES不适合做数据存储</a></p>
<p>Elastic主节点选举算法？？？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.myimy.site/2019/01/28/Elasticsearch的分布式设计原理/" data-id="cjt894lfs00009v00agxaq6v1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/todo/">todo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何避免过多的ifelse" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/10/如何避免过多的ifelse/" class="article-date">
  <time datetime="2019-01-09T16:00:00.000Z" itemprop="datePublished">2019-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/代码整洁/">代码整洁</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/10/如何避免过多的ifelse/">如何避免过多的ifelse</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>一般的if/else判断大多集中在以下三种情型</strong></p>
<ol>
<li>空值判断</li>
<li>业务判断</li>
<li>状态判断</li>
</ol>
<p><strong>处理方法</strong></p>
<ol>
<li>对控制判断的处理，可以把接口分为内接口和外接口，将空值判断都放在外接口，这样进入内接口的时候就不需要考虑空值判断。</li>
<li>利用多态，抽象出处理基类，对每一种业务类型，用专门的实现类来处理对应逻辑。<br> 这里会带来一个问题，暴露给用户的类就多了，因为需要根据不同的业务场景创建不同的业务实现类，这时解决的方法：<ol>
<li>再封装一层，将实现类的权限降低，只暴露给用户创建实现类的方法。</li>
<li>用工厂模式产生类。</li>
<li>用map将类型与类加载到map中，在使用时根据业务类型动态加载实现类。</li>
</ol>
</li>
</ol>
<p><strong>参考</strong><br><a href="https://mp.weixin.qq.com/s/aT2vH2H8biq3Fh0-lSjqOQ" target="_blank" rel="noopener">减少该死的 if else 嵌套</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.myimy.site/2019/01/10/如何避免过多的ifelse/" data-id="cjt894lgi000k9v00m42t4xch" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码整洁/">代码整洁</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/13/代理模式/">代理模式</a>
          </li>
        
          <li>
            <a href="/2019/03/03/自己动手写一个简单的javaagent（总纲）/">自己动手写一个简单的探针(总纲)</a>
          </li>
        
          <li>
            <a href="/2019/03/03/自己动手写一个简单的javaagent（一）/">自己动手写一个简单的探针（一）</a>
          </li>
        
          <li>
            <a href="/2019/03/02/分布式事务常见解决方案/">分布式事务常见解决方案</a>
          </li>
        
          <li>
            <a href="/2019/03/01/采样率/">采样率</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/">elasticsearch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/代码整洁/">代码整洁</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/博客搭建/">博客搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/链路监控/">链路监控</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/REST/" style="font-size: 12.5px;">REST</a> <a href="/tags/RPC/" style="font-size: 12.5px;">RPC</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/java/" style="font-size: 12.5px;">java</a> <a href="/tags/javaagent/" style="font-size: 12.5px;">javaagent</a> <a href="/tags/todo/" style="font-size: 17.5px;">todo</a> <a href="/tags/代码整洁/" style="font-size: 10px;">代码整洁</a> <a href="/tags/分布式/" style="font-size: 20px;">分布式</a> <a href="/tags/博客搭建/" style="font-size: 15px;">博客搭建</a> <a href="/tags/索引/" style="font-size: 10px;">索引</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/运维/" style="font-size: 10px;">运维</a> <a href="/tags/链路监控/" style="font-size: 17.5px;">链路监控</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 manoo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">总览</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>