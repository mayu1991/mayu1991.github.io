<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>索引的原理</title>
      <link href="/2019/12/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2019/12/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库的索引的原理"><a href="#数据库的索引的原理" class="headerlink" title="数据库的索引的原理"></a>数据库的索引的原理</h1><h1 id="索引的使用场景"><a href="#索引的使用场景" class="headerlink" title="索引的使用场景"></a>索引的使用场景</h1><h1 id="常见的索引有哪些"><a href="#常见的索引有哪些" class="headerlink" title="常见的索引有哪些"></a>常见的索引有哪些</h1><h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga9654d1vij30go0a8mxd.jpg" alt="聚集索引"></p><h2 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h2><h2 id="聚集索引与非聚集索引的区别"><a href="#聚集索引与非聚集索引的区别" class="headerlink" title="聚集索引与非聚集索引的区别"></a>聚集索引与非聚集索引的区别</h2><p><a href="https://www.cnblogs.com/aspwebchh/p/6652855.html">https://www.cnblogs.com/aspwebchh/p/6652855.html</a></p><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p><a href="https://blog.csdn.net/shb_derek1/article/details/77478691">https://blog.csdn.net/shb_derek1/article/details/77478691</a></p><h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><h2 id="反向索引"><a href="#反向索引" class="headerlink" title="反向索引"></a>反向索引</h2><h1 id="索引失效的问题"><a href="#索引失效的问题" class="headerlink" title="索引失效的问题"></a>索引失效的问题</h1><p>遇到过索引失效的情况没，什么时候可能会出现，如何解决<br>什么情况下设置了索引但无法使用，索引无效</p><p>1) 以”%”开头的LIKE语句，模糊匹配：红色标识位置的百分号会导致相关列的索引无法使用</p><p>2) Or语句前后没有同时使用索引</p><p>3) 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型，会使索引无效，产生全表扫描。）</p><p>4) 在索引列上使用IS NULL 或IS NOT NULL操作。索引是不索引空值的，所以这样的操作不能使用索引，可以用其他的办法处理，例如：数字类型，判断大于0，字符串类型设置一个默认值，判断是否等于默认值即可</p><p>5) 在索引字段上使用not，&lt;&gt;，!=，eg&lt;&gt; 操作符（不等于）：不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 用其它相同功能的操作运算代替，如 a&lt;&gt;0 改为 a&gt;0 or a&lt;0</p><ol><li>索引类别（B+树索引、全文索引、哈希索引）</li><li>索引使用的注意事项</li></ol><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://www.cnblogs.com/aspwebchh/p/6652855.html">https://www.cnblogs.com/aspwebchh/p/6652855.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/12/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80ID%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/12/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80ID%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p># </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/12/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2019/12/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p># </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/12/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%B9%82%E7%AD%89%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/12/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%B9%82%E7%AD%89%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p># </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库连接池思考</title>
      <link href="/2019/12/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%80%9D%E8%80%83/"/>
      <url>/2019/12/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要聊连接池"><a href="#为什么要聊连接池" class="headerlink" title="为什么要聊连接池"></a>为什么要聊连接池</h1><p>最近系统在大促期间出现了两例问题，竟然都是和数据库连接池有关。所以在这里，重点梳理下连接池和数据库的情况，并且分析下大规模集群下数据库连接会遇到的问题，以及对应的解决方案。</p><h1 id="SQL的生命周期"><a href="#SQL的生命周期" class="headerlink" title="SQL的生命周期"></a>SQL的生命周期</h1><p>连接池其实是一个资源池。<br>我们先来看下如果要执行一个sql，应用服务器和数据库的交互过程。</p><ol><li>首先需要建立应用服务器和数据库的连接状态，即建立连接</li><li>数据库分配线程执行</li><li>进行sql解析并生成执行计划</li><li>读取必要的数据到内存中执行</li><li>通过之前创建的连接发送结果集给到客户端</li><li>关闭连接并释放资源</li></ol><h1 id="为什么使用连接池"><a href="#为什么使用连接池" class="headerlink" title="为什么使用连接池"></a>为什么使用连接池</h1><h2 id="为什么使用长连接"><a href="#为什么使用长连接" class="headerlink" title="为什么使用长连接"></a>为什么使用长连接</h2><p>当客户端需要和数据库建立连接的时候，有短连接和长连接两种选择：</p><ul><li><p>短连接<br>  只在程序和数据库通信的时候建立连接，执行操作后，连接关闭。</p></li><li><p>长连接<br>  程序之间的连接在建立之后，就一直打开，被后续程序复用。</p></li></ul><p>短连接的优点是简单，占用内存资源较小。缺点是在流量大的场景下可能产生性能问题。</p><p>长连接的优点是可复用，缺点是，维持连接需要占用内存，可能导致内存浪费。</p><p>对数据库来说，创建和销毁连接涉及到CPU的运算、资源的争用、内存的分配和socket的建立等。频繁的创建连接和销毁连接，对数据库来说是不可接受的，所以长连接显然比短连接更适合数据库。</p><h2 id="为什么使用连接池-1"><a href="#为什么使用连接池-1" class="headerlink" title="为什么使用连接池"></a>为什么使用连接池</h2><p>既然长连接更适合数据库，那么这时就出现了连接池。有了连接池，可以通过参数来配置连接数、连接检测、连接的生命周期等。可以做到连接的复用，减少平均连接时间，降级数据服务器的负载。</p><h1 id="连接池的基本实现"><a href="#连接池的基本实现" class="headerlink" title="连接池的基本实现"></a>连接池的基本实现</h1><p>连接池其实是资源池的一种实现。类比java中的线程池，其实连接池将资源由线程换成了连接而已。</p><p>我们可以先看下线程池的处理逻辑：<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9zt459gi3j31f00u0gpf.jpg" alt="线程池的处理逻辑"></p><p>连接池也是类似的处理逻辑：</p><ol><li>线程池预热<br> 通常情况下，连接池在启动的时候会根据最小连接数初始化连接。这一步是为了预热，保证连接池中有可用的线程，再请求大的时候，也可以根据最大连接池动态调整。</li><li>获取连接<ol><li>发现有空闲的管道，可以直接使用。</li><li>如果管道都在忙：<ul><li>管道的数量还没有达到最大连接数，那么直接创建一个新连接。</li><li>管道的数量达到最大连接数，进入等待队列中。<ul><li>等待时间内，如果有空闲管道，可以拿到连接。</li><li>等待时间内，如果一直没有空闲管道，抛出获取连接失败的异常。</li></ul></li></ul></li></ol></li><li>连接池监控<br> 无非就是对连接池使用状态的监控，比如一个连接如果空闲下来了，多久没有使用需要被关闭，比如哪些错误情况下需要重新创建一下连接再放入池子，比如如何定时来验证连接是否有效等等。</li></ol><h1 id="连接池参数配置"><a href="#连接池参数配置" class="headerlink" title="连接池参数配置"></a>连接池参数配置</h1><ul><li>最小连接数</li><li>最大连接数</li><li>等待时间</li><li>连接空闲时间</li></ul><p>如果最小连接池设置过小，在应用业务量突增的时候（或者应用扩容），可能短时间产生连接风暴，这对数据库是不小的冲击。</p><p>如果最小连接池设置过大，就会出现连接过剩的情况，连接一方面因为超过空闲时间被销毁，而销毁后又发现小于最小连接数，又开始创建，进入循环。</p><p>如果最大连接池设置过小，可能会导致大量的连接请求处于等待状态。</p><p>如果最大连接池设置过大，在极端情况下，可能导致数据库的连接数被耗尽，进而导致业务受影响，甚至会形成一系列的连锁反应，乃至雪崩。</p><p>如果等待时间过长，虽然可以尽可能提高得到连接的效率，但是当应用并发很高，大大超过了连接池数量，队列就无法起到缓冲的作用，反而会阻塞应用，大量积压的线程会导致应用宕机。</p><h1 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h1><p>我们可以想象下在什么场景，需要面对连接池优化的问题？<br>无非这两点：</p><ol><li>连接数太多</li><li>并发量太大</li></ol><p>首先，我们来看下一个应用的连接数由哪些因素决定的：</p><ul><li>应用服务器的数量</li><li>db数</li><li>连接池配置的最小连接数和最大连接数</li></ul><blockquote><p>e.g 假设一个应用，共100台服务器，连接2个db，连接池配置的最大连接数是10，那么这个应用的总连接数就是100*2*10 = 2000</p></blockquote><p>围绕这三个因素，我们可以得到多连接数优化的基本思路：</p><ul><li>拆分和降低连接池，降低单实例MySQL的连接数，比如原来一个实例上面有2个DB， 通过拆分一个实例只有1个DB， 那么在应用服务器不变的情况下， 连接数就变成1*500*6=3000。</li><li>提高DB响应时间，这样在系统同样处理能力的情况下，连接池的连接数可以大大减少。</li><li>减少应用集群规模。</li></ul><h2 id="提高DB响应时间"><a href="#提高DB响应时间" class="headerlink" title="提高DB响应时间"></a>提高DB响应时间</h2><ol><li>索引优化<br> //补充索引原理以及优化</li><li>事务优化<br> //补充事务优化</li><li>提高DB性能    <ol><li>数据拆分<br>对数据进行分片，引入多个SQL实例，这样数据库的整体并发服务能力自然提升，同时由于服务压力被打散，整个数据库集群表现的性能也会更好。</li><li>DB服务器升级</li></ol></li></ol><h2 id="提高数据库的并发能力"><a href="#提高数据库的并发能力" class="headerlink" title="提高数据库的并发能力"></a>提高数据库的并发能力</h2><p>我们可以发现，其实多连接数和高并发是相辅相成的，通过以上的手段减少连接数，一方面减轻了db服务器的压力，但是也有可能降低了应用服务器的并发能力。那有没有既能减少连接数又不影响高并发的优化方法呢？</p><ul><li>将事务和连接解绑，比如增加一层proxy</li><li>使用mysql线程池，线程和连接解绑</li></ul><h2 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h2><p>线上遇到连接数溢出的问题，问题的排查步骤？</p><ol><li>查看实例配置（几核几G、支持的最大连接数）</li><li>查看当前连接数（<code>show processlist</code>）</li><li>排查是什么动作占用了这些连接</li><li>分析连接被占用的原因<ul><li>慢SQL（缺索引、join太多、查询数据没有分页等）</li><li>长事务</li><li>死锁</li></ul></li></ol><h2 id="应急手段"><a href="#应急手段" class="headerlink" title="应急手段"></a>应急手段</h2><ol><li>服务端扩容<br> 对请求进行分流，增加了服务端的并发处理能力。不过，应用服务器的增加同时会带来连接数的增加，在db连接数足够的情况下，可以执行这样的操作。</li><li>服务端限流<br> 这是最快速也是最有效的方法。牺牲部分用户体验，以保住整个系统的稳定。</li><li>DB实例重启<br> 重启应用可以释放当前连接数。弊端有：<ol><li>当前连接中的数据丢失，执行失败</li><li>治标不治本，如果是性能问题，这么做只能解一时的渴</li></ol></li><li>DB实例扩容<br> DB服务器升级，这也只适用于可以动态升级的云上服务器（比如阿里云服务器）一般的硬件服务器，升级配置还是挺麻烦的吧（个人猜测）<br> DB服务集群扩容，涉及数据备份的问题，应该需要充分的测试和演练吧，需要一定的运维能力。</li><li>紧急代码优化<ul><li>DB增加索引</li><li>修复造成死锁的代码问题</li><li>优化慢sql</li></ul></li></ol><h1 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h1><p><a href="https://segmentfault.com/a/1190000014044351">一篇搞懂TCP、HTTP、Socket、Socket连接池</a></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li>《java并发编程的艺术》</li><li><a href="https://juejin.im/post/5b7944c6e51d4538c86cf195#heading-8">数据库连接池技术详解</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 连接池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String整理</title>
      <link href="/2019/11/08/java%E5%9F%BA%E7%A1%80/String%E6%95%B4%E7%90%86/"/>
      <url>/2019/11/08/java%E5%9F%BA%E7%A1%80/String%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="hashCode方法详解"><a href="#hashCode方法详解" class="headerlink" title="hashCode方法详解"></a>hashCode方法详解</h1><p><a href="https://blog.csdn.net/claram/article/details/53770830">Java编程：String 类中 hashCode() 方法详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList整理</title>
      <link href="/2019/11/08/java%E5%9F%BA%E7%A1%80/ArrayList%E6%95%B4%E7%90%86/"/>
      <url>/2019/11/08/java%E5%9F%BA%E7%A1%80/ArrayList%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList扩容处理"><a href="#ArrayList扩容处理" class="headerlink" title="ArrayList扩容处理"></a>ArrayList扩容处理</h1><p><a href="https://blog.csdn.net/magi1201/article/details/84638636">ArrayList扩容处理</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap整理</title>
      <link href="/2019/11/06/java%E5%9F%BA%E7%A1%80/HashMap%E6%95%B4%E7%90%86/"/>
      <url>/2019/11/06/java%E5%9F%BA%E7%A1%80/HashMap%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-的工作原理及代码实现"><a href="#HashMap-的工作原理及代码实现" class="headerlink" title="HashMap 的工作原理及代码实现"></a>HashMap 的工作原理及代码实现</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>关键属性  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;<span class="comment">//存储元素的实体数组（桶）</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;<span class="comment">//存放元素的个数</span></span><br><span class="line"><span class="keyword">int</span> threshold; <span class="comment">//临界值= 加载因子*容量，当实际大小超过临界值时 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">//加载因子，记录数/容量，默认值0.75</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;<span class="comment">//被修改的次数，HashMap内部结构发生变化的次数</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>关键动作</p><ul><li>初始化<ul><li>容量，默认16</li><li>负载因子，默认0.75f</li></ul></li><li><p>hash</p><ul><li><p>hashcode的生成</p><ul><li>Object对象：内存地址</li><li>String对象：char数组每一位都参与运算，对于相同值的String，hashcode是相同的</li><li>Integer：Integer的value</li></ul></li><li><p>key的hash<br>一次扰动（高位也参与异或计算，增加hash的分散性）</p></li></ul></li><li>散列函数<br>  (length-1)&amp;hash</li><li>扩容<ul><li>扩容后的容量<ul><li>当前容量的两倍</li><li>先插入再扩容</li></ul></li><li>再hash</li></ul></li><li>插入</li><li>删除</li><li>查询</li></ul></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="size和threshold的区别"><a href="#size和threshold的区别" class="headerlink" title="size和threshold的区别"></a>size和threshold的区别</h3><ul><li>size是map中实际存在的键值对数量</li><li>threshold是map内最大装载的元素的个数</li><li>当size达到threshold时，就会触发reSize和reHash</li></ul><h3 id="为什么HashMap的桶的大小为2的指数倍？"><a href="#为什么HashMap的桶的大小为2的指数倍？" class="headerlink" title="为什么HashMap的桶的大小为2的指数倍？"></a>为什么HashMap的桶的大小为2的指数倍？</h3><p>我们在使用hashmap的时候，肯定是期望碰撞越小越好。</p><blockquote><p>那么如何达到这个目的呢？</p></blockquote><p>我觉得可以从以下三点入手：</p><ul><li>更大的存储空间，当然可以使数据的分布更分散</li><li>更好的的散列函数，使数据的分布更均匀</li><li>解决冲突的方法</li></ul><blockquote><p>怎么实现更大的存储空间呢？</p></blockquote><ul><li>增加内存空间</li><li>增加负载因子</li></ul><p>内存空间和负载因子的抉择，就是经典的「时间-空间」问题。是牺牲时间换取空间，还是牺牲空间换取时间？视实际情况而定。可以用一句话总结：「负载因子越大，碰撞的概率越大；负载因子越小，碰撞的概率变小，但是内存闲置的概率也会增加」</p><p>HashMap的初始空间和初始的负载因子分别是16和0.75f，通常不建议改变负载因子，初始空间建议按照expectSize/0.75 + 1来设置，为什么这么设计，因为扩容是一个很耗资源的操作，我们如果能预估到map中元素的个数，依照这个预估值设置容量，可以减少扩容的操作。</p><blockquote><p>更好的散列函数？</p></blockquote><p>我们知道其实hash就是一个以空间换时间的设计。每一个key通过散列函数的计算，放入相应的位置上。最好的方式是根据桶的大小（hashmap的）计算取余。</p><ul><li>桶的大小怎么设计才合理</li><li>散列函数怎么设计才合理</li></ul><p>桶的大小<br>有证明其实素数在打散的效果上是更好的，可以参考这个文章<a href="https://blog.csdn.net/liuqiyao_01/article/details/14475159">为什么一般的hashTable的桶数会取一个素数</a>。但是HashMap还是选择了2的指数幂作为桶数。这就引出了「为什么HashMap的桶的大小为2的指数倍」这个问题。</p><p>散列函数<br>为什么HashMap的桶的大小为2的指数倍？<br>这是从性能角度出发的，为了优化用位运算代替取余运算，同时也方便在扩容时优化。</p><ul><li>只有长度为2的指数幂的时候，位运算和取余运算才相等，这个时候散列函数计算结果比较分散。</li><li>网上有一种说法，如果length为奇数，length-1为偶数，最后一位肯定是0，这时位运算之后，最后一位永远是零，散列就不分散了。我觉得这个说法不是这个问题的原因，而是结果。</li></ul><p>总结一下，因为选择用位运算代替除法来作为散列函数，而为了保证位运算的足够分散，选择了2的指数幂作为标准。（ps：因为选择了2的指数幂，在扩容时还可以更快捷）</p><h3 id="为什么扩容之后的size是两倍"><a href="#为什么扩容之后的size是两倍" class="headerlink" title="为什么扩容之后的size是两倍"></a>为什么扩容之后的size是两倍</h3><p>因为hashmap的容量是2的指数幂，所以扩容之后也必须是2的指数幂，扩容的倍数当然也是2的指数幂。<br>至于为什么是两倍，这应该是一个取舍，一下子不需要扩太多。</p><h3 id="为什么先插入再扩容而不是先扩容再插入"><a href="#为什么先插入再扩容而不是先扩容再插入" class="headerlink" title="为什么先插入再扩容而不是先扩容再插入"></a>为什么先插入再扩容而不是先扩容再插入</h3><ol><li>hashmap的插入有可能是覆盖原有的值，这个时候size并没有增加，如果是先扩容后插入，会造成资源浪费。</li><li>因为hashmap是数组+链表，并且有负载因子，所以先插入并不会带来溢出的问题。而扩容是很耗资源的操作，能避免则避免。</li></ol><h3 id="rehash带来的死锁"><a href="#rehash带来的死锁" class="headerlink" title="rehash带来的死锁"></a>rehash带来的死锁</h3><h2 id="ConcurrentHashMap-的工作原理及代码实现"><a href="#ConcurrentHashMap-的工作原理及代码实现" class="headerlink" title="ConcurrentHashMap 的工作原理及代码实现"></a>ConcurrentHashMap 的工作原理及代码实现</h2><blockquote><p>如何统计所有的元素个数??</p></blockquote><p><strong>锁分段技术</strong></p><ul><li>获取segment<br>  根据concurrentLevel确定segment数组的大小，其实就是确定锁的多少<br>  获取hash，需要再散列，为了把分布打散，比hashMap打散的更彻底</li><li>get<br>volitile修饰所有变量，保持可见性</li><li>put<br>  （1）判断容量是否足够，如果不够的话，对segment扩容，新建一个2倍大小的数组插入，先判断后扩容，hash是先扩容后判断<br>  （2）加锁插入，其实segment内部的实现跟hashmap很相似</li><li>size<br>将所有的segment的大小相加，但是在多线程的时候，不能保证count的值在计算的过程中不变化，所以会尝试两次计算size，如果两次都失败了，再锁住所有segment，进行容量计算。</li></ul><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><ul><li><p>HashMap 和 Hashtable 的区别<br><a href="http://www.importnew.com/24822.html">http://www.importnew.com/24822.html</a><br>（1）hashtable是线程安全的，所有的方法都加上了synchronized<br>（2）初始容量、扩容和hash算法不同<br>hashMap 16，扩容是*2，hash直接用位运算取模，效率高但是偶数分布不均匀，所以又跟length-1与了一下，将hash打散<br>hashTable 11，扩容是*2+1，hash用除法取模，分布均匀但是效率比较低<br>（3）1.8以及以后，hashmap的链表用红黑树存储了，提高了查询效率</p></li><li><p>HashMap 和 HashSet 区别<br><a href="https://blog.csdn.net/u010698072/article/details/52802179">https://blog.csdn.net/u010698072/article/details/52802179</a><br>hashSet其实内部就是用hashMap实现的，hashSet服务于对象，在add的时候将这个对象作为map的key，set内部会new一个final类型修饰的Object作为value。</p></li><li><p>HashMap 和 ConcurrentHashMap 的区别<br>ConcurrentHashMap是线程安全的，ConcurrentHashMap使用了锁分段技术，维护了一个继承ReetrantLock的的segment数组，每一个segment对象对应部分Entry。</p></li><li><p>java 1.7和1.8版本中hashmap的区别</p></li></ul><h1 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h1><ul><li><p>hashMap的优化方案<br><a href="http://www.importnew.com/21429.html">http://www.importnew.com/21429.html</a></p></li><li><p>谈谈HashMap，哈希表解决hash冲突的方法；</p><ul><li>开放定址</li><li>再hash</li><li>链地址法</li><li>建立公共溢出区<br><a href="https://www.cnblogs.com/wuchaodzxx/p/7396599.html">参考</a></li></ul></li></ul><blockquote><p>java 8 在链表长度达到8，桶的数量达到64的时候，会建一个红黑树来保存元素</p></blockquote><ul><li><p>多线程情况下HashMap死循环的问题<br>两个线程在rehash的时候，因为有next = e.next;e = next;的操作，有可能形成环路。<br><a href="https://coolshell.cn/articles/9606.html">参考</a></p></li><li><p>hashMap什么时候用到红黑树<br><a href="https://blog.csdn.net/u011240877/article/details/53358305">java1.8中当单链的长度超过8的时候会转化为红黑树</a><br><a href="https://blog.csdn.net/u011240877/article/details/53329023">什么是红黑树</a><br><a href="https://blog.csdn.net/sun_tttt/article/details/65445754">https://blog.csdn.net/sun_tttt/article/details/65445754</a></p></li><li><p>HashMap出现Hash DOS攻击的问题<br>把key都设计成一个hash，这样插入就成为一个单链表结构了<br><a href="https://coolshell.cn/articles/6424.html">https://coolshell.cn/articles/6424.html</a></p></li><li><p>一致性hash算法<br>  <a href="https://juejin.im/post/5ae1476ef265da0b8d419ef2">参考</a></p></li></ul><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><p><a href="https://www.cnblogs.com/ysocean/p/9054804.html">HashMap的求余%和与运算&amp;转换问题</a><br><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">HashMap原理和源码分析</a><br><a href="https://blog.csdn.net/liuqiyao_01/article/details/14475159">HashTable的桶数为什么取素数</a><br><a href="https://blog.csdn.net/qq_36520235/article/details/82417949">HashMap的结构，1.7和1.8有哪些区别</a><br><a href="https://blog.csdn.net/mgl934973491/article/details/60466487">HashMap的扩容机制</a><br><a href="http://www.cnblogs.com/ITtangtang/p/3948406.html">HashMap源码解析</a><br><a href="https://juejin.im/post/5ab99afff265da23a2291dee">HashMap的hash方法剖析</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> hashmap </tag>
            
            <tag> concurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式编程知识点汇总</title>
      <link href="/2019/11/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%94%81/"/>
      <url>/2019/11/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><ol><li><p>说说 CountDownLatch、CyclicBarrier 原理和区别</p><ul><li><p>CountDownLatch 允许一个线程或多个线程等待其他线程完成工作。<br>一个获取共享状态的同步器。</p></li><li><p>CyclicBarrier 允许多个线程在都达到一个屏障的时候再放开屏障。<br>一个锁，用锁的condition来操作，await()<br>区别：</p></li><li>CyclicBarrier 可以重置计数器，适合比较复杂的业务场景，提供的方法也比较多</li></ul></li><li><p>说说 Semaphore 原理<br> 控制同一时间并发的线程数（共享式的同步器）<br> 在构造函数里输入并发的数量，用acquire和release来控制同步块</p></li><li>说说 Exchanger 原理<br> 线程间协作，两个线程在到达同一时刻之后，可以交换数据（wait/notify）<br>执行exchange（）方法</li><li>ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理 ？？？？<br><a href="https://juejin.im/post/5a64a581f265da3e3b7aa02d">https://juejin.im/post/5a64a581f265da3e3b7aa02d</a></li><li>常见的原子操作类<br>AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference</li><li>AtomicInteger底层实现原理；<br> 一个volatile类型的value值，封装了原子性读改写的方法，利用了unsafe类的compareAndSwagObject/int/long<br>value这个字段在AtomicInteger类的内存中相对于该类首地址的偏移量</li><li>Java 8并法包下常见的并发类，用过并发包下边的哪些类</li><li>AQS同步队列(ReetrantLock依赖AQS)<ul><li>同步状态state控制获取锁的方式（共享、独占、可重入）。</li><li>同步队列实现，实现线程的排队、等待和唤醒的工作。</li></ul></li><li>fork/join<br> <a href="https://juejin.im/post/59be875e5188257e6b6d91c1">https://juejin.im/post/59be875e5188257e6b6d91c1</a></li><li>JMM不保证对64位的long和double型变量的写操作具有原子性<br><a href="https://blog.csdn.net/luoyoub/article/details/80275539">https://blog.csdn.net/luoyoub/article/details/80275539</a></li></ol><h1 id="线程与线程池"><a href="#线程与线程池" class="headerlink" title="线程与线程池"></a>线程与线程池</h1><ol start="12"><li><p>一个线程连着调用start两次会出现什么情况？<br>会抛出一个IllegalThreadStateException</p></li><li><p>wait方法能不能被重写，wait能不能被中断；<br>不能被重写，是final修饰的，不可以被中断，wait方法会抛出中断异常。</p></li><li><p>线程池的几种实现方式</p></li><li>讲讲线程池的实现原理</li><li><p>线程池的实现？四种线程池？重要参数及原理？饱和策略有哪几种？</p></li><li><p>线程和进程的概念、并行和并发的概念<br>线程是操作系统执行的最小单元。<br>并行：多个cpu<br>并发：在同一个cpu里，多个线程同事执行同一个任务</p></li><li><p>创建线程的方式及实现<br>三种方式：<br>（1）继承一个线程Thread，并实现run方法<br>（2）实现一个runnable接口<br>（3）实现一个callable接口，这个接口支持获取线程执行的返回值</p></li><li><p>进程间通信的方式<br><a href="https://www.cnblogs.com/LUO77/p/5816326.html">https://www.cnblogs.com/LUO77/p/5816326.html</a></p></li><li><p>说说线程安全问题，什么是线程安全，如何保证线程安全</p></li><li><p>线程状态以及API怎么操作会发生这种转换；<br>NEW new<br>RUNNALBLE start<br>BLOCKED 尝试进入synchonized区域<br>TERMINATED 执行完run的时候<br>WAITING wait、join、sleep（time——waiting状态，时间到了自己唤醒自己）</p></li></ol><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><ol><li><p>重入锁的概念，重入锁为什么可以防止死锁<br>支持重进入的锁，可重入锁对象在线程尝试去获取同步状态的时候，会先判断状态，如果等于0，那就是第一次进入，进行正常的锁获取，如果大于0的时候，判断当然锁是不是只属于当前线程，如果是，状态值就是获取锁的次数。</p></li><li><p>产生死锁的四个条件<br>（互斥、请求与保持、不剥夺、循环等待）</p></li><li><p>如何检查死锁（通过jConsole检查死锁）</p></li><li><p>常用的避免死锁方法；</p><ul><li>避免一个线程同时获取多个锁。</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>尝试使用定时锁，使用 lock.tryLock(timeout) 来替代使用内部锁机制。</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li></ul></li><li><p>CAS无锁的概念、乐观锁和悲观锁<br> 利用java提供的cmpxchg指令，完成操作的同步。<br> 对于竞争比较小的，占用资源时间比较短的业务场景，可以使用CAS的模式来代替加锁，这种方式响应时间快，但是如果一直自旋的话也会消耗大量的cpu。<br> 如果加了锁的话，所有获取该锁的线程都要处于阻塞状态，响应时间慢，追求吞吐量。</p><p> 乐观锁：cas的概念，乐观的认为出现竞争的机会比较小，通过比较原始值和最新值的方式来更新。<br> 悲观锁：同步的概念，悲观的认为每次更新都有可能会出错，所以锁住这个资源，同一时刻只允许一个线程操作。</p></li><li><p>CAS机制会出现什么问题；</p><ul><li><p>乐观锁只能保证一个共享变量的原子操作。如上例子，自旋过程中只能保证value变量的原子性，这时如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。</p></li><li><p>长时间自旋可能导致开销大。假如CAS长时间不成功而一直自旋，会给CPU带来很大的开销。</p></li><li><p>ABA问题。CAS的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。</p></li></ul></li><li>什么是ABA问题，出现ABA问题JDK是如何解决的<br>Cas带来的问题，因为cas的机制是对比历史值，在某些场景下，有可能其他线程修改完之后改成了历史值，这个时候cas也是可以成功的。<br>在jdk里有一个atomicStampedReference类，可以在比较的时候再加上标签比较。</li><li><p>乐观锁的业务场景及实现方式<br> 读取频繁用乐观锁，写入频繁用悲观锁<br> <a href="https://blog.csdn.net/claram/article/details/53959367">https://blog.csdn.net/claram/article/details/53959367</a></p></li><li><p>偏向锁、轻量级锁、重量级锁、自旋锁的，自适应自旋锁，锁消除，锁粗化，锁的升级</p></li><li><p>synchronized与ReentraLock哪个是公平锁；<br>Synchronized 是非公平锁，因为它无法保证释放的锁会被哪个线程获取到。<br>Reentrant 既有公平锁也有非公平锁</p></li><li><p>synchronized 与 lock 的区别</p><ul><li>lock ：虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。<ul><li>尝试非阻塞地获取锁</li><li>能被中断地获取锁</li><li>超时获取锁</li><li>Lock是基于同步队列实现的</li></ul></li><li>synchronized<ul><li>使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。当然，这种方式简化了同步的管理，可是扩展性没有显示的锁获取和释放来的好。</li><li>synchronized是jvm内部实现的</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
            <tag> 分布式编程 </tag>
            
            <tag> 锁 </tag>
            
            <tag> 线程池 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用关键字</title>
      <link href="/2019/09/03/java%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/09/03/java%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h1><p><a href="https://www.cnblogs.com/lanxuezaipiao/p/3369962.html">Java transient关键字使用小记</a></p><ol><li><p>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</p></li><li><p>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p></li><li><p>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</p></li></ol><h1 id="volatile-实现原理"><a href="#volatile-实现原理" class="headerlink" title="volatile 实现原理"></a>volatile 实现原理</h1><p>禁止指令重排、刷新内存<br>LoadLoad：禁止上面的volatile读与下面的普通读重排序<br>LoadStore：禁止上面的volatile读与下面的普通写重排序<br>StoreLoad：禁止上面的volatile写与下面的volatile读/写重排序<br>StoreStore：禁止上面的所有操作与下面的volatile写重排序</p><h1 id="synchronized-实现原理（对象监视器）"><a href="#synchronized-实现原理（对象监视器）" class="headerlink" title="synchronized 实现原理（对象监视器）"></a>synchronized 实现原理（对象监视器）</h1><p>利用了对象的对象监视器 monitor ，每一个对象都有自己的对象锁，当这个对象被synchronized修饰了之后，jvm编译的时候会在获取这个对象实例之前插入一个monitor enter指令</p><h1 id="final关键字的内存语义"><a href="#final关键字的内存语义" class="headerlink" title="final关键字的内存语义"></a>final关键字的内存语义</h1><p><a href="https://www.jianshu.com/p/1f4b0f98cbf1">参考</a></p><ul><li>final可以修饰类，该类不能被继承。</li><li>final可以修饰方法，该方法不能被重写。(覆盖，复写)</li><li>final可以修饰变量，该变量不能被重新赋值。因为这个变量其实是常量。</li><li>final如果修饰形参，其实仍然是可以对这个参数修改。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础知识点汇总</title>
      <link href="/2019/09/01/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/"/>
      <url>/2019/09/01/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ol><li>序列化的使用场景与意义<br> <a href="https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf#hserialversionuid">https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf#hserialversionuid</a></li><li>序列化版本号的作用<br> <a href="https://blog.csdn.net/yangyang3_/article/details/80718768">https://blog.csdn.net/yangyang3_/article/details/80718768</a></li></ol><h1 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h1><p><a href="https://www.jianshu.com/p/54c91a620d35">参考</a></p><p>向左位移相当于乘以 2^n ,向右移动正数相当于除以 2^n （ n 为位移的位数）<br>比如1&lt;&lt;30，表示1乘以2^30</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用工具记录</title>
      <link href="/2019/07/16/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/07/16/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><a href="https://www.bejson.com/">一个包含很多实用工具的网站</a><br><a href="https://www.json.cn/">简单的json格式化</a></p><h1 id="时间戳转化工具"><a href="#时间戳转化工具" class="headerlink" title="时间戳转化工具"></a>时间戳转化工具</h1><p><a href="http://tool.chinaz.com/Tools/unixtime.aspx">http://tool.chinaz.com/Tools/unixtime.aspx</a></p><h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><p><a href="https://toolinbox.net/iPic/">https://toolinbox.net/iPic/</a></p><h1 id="在线颜色选择器"><a href="#在线颜色选择器" class="headerlink" title="在线颜色选择器"></a>在线颜色选择器</h1><p><a href="http://www.shouce.ren/tool/yanse">http://www.shouce.ren/tool/yanse</a></p><h1 id="在线图片去底色工具"><a href="#在线图片去底色工具" class="headerlink" title="在线图片去底色工具"></a>在线图片去底色工具</h1><p><a href="http://www.aigei.com/bgremover">http://www.aigei.com/bgremover</a></p><h1 id="在线二维码生成器"><a href="#在线二维码生成器" class="headerlink" title="在线二维码生成器"></a>在线二维码生成器</h1><p><a href="http://www.liantu.com/">http://www.liantu.com/</a></p><h1 id="pdf转word"><a href="#pdf转word" class="headerlink" title="pdf转word"></a>pdf转word</h1><p><a href="https://smallpdf.com/cn/pdf-to-word">https://smallpdf.com/cn/pdf-to-word</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring validation 使用踩坑</title>
      <link href="/2019/04/10/java%E5%9F%BA%E7%A1%80/spring%20validation%20%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/"/>
      <url>/2019/04/10/java%E5%9F%BA%E7%A1%80/spring%20validation%20%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/dream_broken/article/details/53584169">java使用validator进行校验</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/index.html">JSR 303 - Bean Validation 介绍及最佳实践</a></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> todo </tag>
            
            <tag> spring </tag>
            
            <tag> validation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议</title>
      <link href="/2019/04/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/04/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h1><p><a href="https://blog.csdn.net/cnh294141800/article/details/53768464">https://blog.csdn.net/cnh294141800/article/details/53768464</a></p><p><a href="https://www.zhihu.com/question/19787937">https://www.zhihu.com/question/19787937</a></p><h1 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h1>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> todo </tag>
            
            <tag> 一致性协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo学习</title>
      <link href="/2019/03/04/dubbo/dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/03/04/dubbo/dubbo%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="dubbo的拓展点机制"><a href="#dubbo的拓展点机制" class="headerlink" title="dubbo的拓展点机制"></a>dubbo的拓展点机制</h1><p><a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html">官方博客解释</a></p><p>参考：<br><a href="https://www.imooc.com/article/266672">DUBBO原理、应用</a></p><h2 id="自适应类"><a href="#自适应类" class="headerlink" title="自适应类"></a>自适应类</h2><p>自适应类，dubbo的每一个拓展点都会有一个自适应类，如果我们没有提供，dubbo会帮我们动态的生成一个。</p><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><h2 id="字节码生成工具"><a href="#字节码生成工具" class="headerlink" title="字节码生成工具"></a>字节码生成工具</h2><p>动态加载</p>]]></content>
      
      
      <categories>
          
          <category> todo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己动手写一个简单的探针（一）</title>
      <link href="/2019/03/04/%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84javaagent%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/03/04/%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84javaagent%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>实现一个简单的javaagent。</li></ol><a id="more"></a><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="Step1-搭建agent的框架，实现动态加载"><a href="#Step1-搭建agent的框架，实现动态加载" class="headerlink" title="Step1 搭建agent的框架，实现动态加载"></a>Step1 搭建agent的框架，实现动态加载</h3><blockquote><p>Premain.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Premain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> <span class="keyword">throws</span> ClassNotFoundException, UnmodifiableClassException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"enter agent premain..."</span>);</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> Transformer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Transformer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; classNameSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        classNameSet.add(<span class="string">"com.example.demo.AgentTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增强类 eg:静态注入监控代码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] enhanceMethod(String className) &#123;</span><br><span class="line">        <span class="comment">//增强代码 todo</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每加载一个类都会调用？</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalClassFormatException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader l, String className, Class&lt;?&gt; c,</span><br><span class="line">                            ProtectionDomain pd, <span class="keyword">byte</span>[] b) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        <span class="comment">//判断当前的类是否需要转换</span></span><br><span class="line">        String currentClassName = className.replaceAll(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (!classNameSet.contains(currentClassName)) &#123; <span class="comment">// 仅仅提升Set中含有的类</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回增强之后的类</span></span><br><span class="line">        <span class="keyword">return</span> enhanceMethod(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>pom.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>myagent<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>com.manoo.agent.Premain<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建了一个springboot项目，在VM options里加上以下指令测试javaagent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:/Users/mayu/Documents/mycodes/myagent/target/myagent.jar</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestagentApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"application main"</span>);</span><br><span class="line">        SpringApplication.run(TestagentApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>启动之后发现程序有报错</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: com.manoo.agent.Premain</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:304)</span><br><span class="line">at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:401)</span><br><span class="line">FATAL ERROR in native method: processing of -javaagent failed</span><br></pre></td></tr></table></figure><p>看了下myagent.jar包里是有这个类的，路径也没有问题。为什么会找不到这个类？</p><ol><li><p>猜测是类加载器的问题。<br>于是研究了下javaagent的类加载原理，发现不是classloader的问题。</p><blockquote><p>因为双亲类加载的原因，javaagent是无法获取应用程序的类，但是我这里是直接获取javaagent自己的类，所以不是classloader的问题。</p></blockquote><p> <a href="http://ifeve.com/classnotfoundexception-is-it-slowing-down-your-jvm/">ClassNotFoundException: 真的会使你的JVM慢下来吗？</a><br> <a href="https://blog.csdn.net/belalds/article/details/83105685">深入理解Java ClassLoader及在 JavaAgent 中的应用</a></p></li></ol><ol start="2"><li><p>将<code>myagent.jar</code>解压了一下，发现确实没有<code>com.manoo.agent.Premain</code>这个类，再看看发现我的classes类是在BOOT-INF/classes 路径下了。为了方便，我是直接用Spring boot创建的项目。用了<a href="https://www.cnblogs.com/acm-bingzi/p/mavenSpringBootPlugin.html">spring-boot-maven-plugin</a>打包，导致项目被打成了Spring boot的结构的jar包。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p> <img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0z5u8rz00j30ve0hadji.jpg" alt="spring boot项目打包后的MANIFEST"></p><blockquote><p>后来一想如果javaagent用springboot，会不会有点太重了。目前这个javaagent功能还很简单，还不要使用框架。</p></blockquote><p> 于是把spring boot的依赖注释掉，重新编译了下myagent，拿到jar包之后解压了下，现在正常了。<br> <img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0zt6er9ncj30r007sdgr.jpg" alt="jar解压后的文件夹"></p><p> <img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0ztdruallj30se088q49.jpg" alt="去掉spring boot之后打包生成的MANIFEST"></p><p> <img src="https://ws4.sinaimg.cn/large/006tKfTcly1g10bbfa8x7j312c046ab2.jpg" alt="正常运行结果"></p></li></ol><h3 id="Step2-实现被监控类的增强"><a href="#Step2-实现被监控类的增强" class="headerlink" title="Step2 实现被监控类的增强"></a>Step2 实现被监控类的增强</h3><ol><li>判断哪些类需要被监控或者说被增强</li><li>怎么实现被监控类的增强<ul><li>javassist</li><li>byteBuddy<a href="https://notes.diguage.com/byte-buddy-tutorial/">（教程）</a></li></ul></li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><a href="https://mayu1991.github.io/2019/03/13/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">代理模式</a></li><li>动态生成字节码的框架有哪些，效率如何？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 链路监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 链路监控 </tag>
            
            <tag> javaagent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己动手写一个简单的探针(总纲)</title>
      <link href="/2019/03/03/%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84javaagent%EF%BC%88%E6%80%BB%E7%BA%B2%EF%BC%89/"/>
      <url>/2019/03/03/%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84javaagent%EF%BC%88%E6%80%BB%E7%BA%B2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>实现对当前容器系统参数（cpu，内存，网络）的收集，并将信息上传到服务端。</li><li>实现一个对代码无侵入的探针，只要应用程序启动了，就自行运转，无需应用程序进行改造。</li><li>实现agent的心跳检测。</li><li>实现根据采样率调节数据收集量。</li></ol><a id="more"></a><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><p>怎么在代码无侵入的要求下运行监控程序？</p><ul><li>如果要做到无侵入，那么探针势必要与应用程序运行在一个进程里。如果探针单独部署，应用程序肯定是要做代码层面的改造与探针服务进行交互。</li><li>如何将探针的程序注入到应用程序里呢？利用 <a href="https://www.infoq.cn/article/javaagent-illustrated">javaagent的Instrument</a>。</li></ul></li><li><p>怎么收集当前容器信息？</p><ul><li>用javaagent实现无侵入部署，在启动应用程序的同时，注入探针的代码，探针会启动一个定时器，由定时器来控制触发系统指标收集的任务。</li><li>同时再启动一个定时器，实现心跳机制。</li></ul></li></ol><blockquote><p>为什么要做心跳？因为agent是单独部署在客户端的，服务端是开发者自己能够hold住的，客户端就有点鞭长莫及。所以需要用心跳来知晓agent的运行情况。</p></blockquote><ol start="3"><li>用什么方式上传到服务端？</li><li>服务端数据结构怎么设计，用什么样的DB保存数据？</li><li>如何实现采样率的动态调节？</li></ol><h2 id="技术准备"><a href="#技术准备" class="headerlink" title="技术准备"></a>技术准备</h2><ol><li><p>利用instrument agent实现探针无侵入</p><p> <strong>Instrument</strong></p><p> “java.lang.instrument”包的具体实现，依赖于JVMTI。在Java SE 5 及其后续版本当中，开发者可以在一个普通 Java 程序（带有 main 函数的 Java 类）运行时，通过 <code>- javaagent</code>参数指定一个特定的jar文件来启动 Instrumentation的代理程序。</p><p> Instrumentation 的最大作用，就是类定义动态改变和操作。而且指令里也可以加上一些启动参数。</p><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html">怎么获取启动参数？</a></p></blockquote><p> <strong>JVMTI</strong></p><p> JVMTI全称 JVM Tool Interface，是 JVM 暴露出来的一些供用户扩展的接口集合。JVMTI 是基于事件驱动的，JVM 每执行到一定的逻辑就会调用一些事件的回调接口（如果有的话），这些接口可以供开发者扩展自己的逻辑。</p><pre><code>JVMTIAgent 其实就是一个动态库，利用 JVMTI 暴露出来的一些接口来干一些我们想做、但是正常情况下又做不到的事情。</code></pre><p> JVMTIAgent有三个回调函数，分别是：</p><ul><li>Agent_OnLoad，启动时加载。</li><li>Agent_OnAttach，运行时加载，这里还需要利用java的attach原理。</li><li><p>Agent_OnUnload，卸载时加载。</p><p>个人感觉这里应该用启动时加载，因为监控程序应该是7*24小时运行，必须与被监控应用相同的生命周期。如果是运行时加载，在什么样的节点启动监控也是很难定义。</p></li></ul></li><li><p>利用Byte buddy实现了类的运行时动态加载和类的加强</p></li></ol><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><ol><li>加载agent配置</li><li>加载agent插件</li><li>初始化agent服务管理<ol><li>SPI<br>JDK内置的一种服务提供发现机制</li><li>动态加载BootService接口的实现类</li><li>插件加载、匹配和拦截</li></ol></li></ol><h2 id="agent插件体系"><a href="#agent插件体系" class="headerlink" title="agent插件体系"></a>agent插件体系</h2><ol><li>插件的加载<ol><li>自定义的类加载器AgentClassLoader </li><li>注册</li><li>动态加载</li></ol></li><li>插件的匹配</li><li>插件的拦截<ol><li>指定需要拦截的类：在AgentBuilder.type处，这里可以指定需要拦截的类</li><li>指定需要拦截的方法：在builder.method处，这里可以指定需要拦截的方法</li><li>将需要拦截的<a href="https://www.jianshu.com/p/fe1448bf7d31">类重新定义加载【ByteBuddy】</a>       </li></ol></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>PluginFinder<br>初始化方法：遍历所有pluginDefine，并获取classMatch，放到不同的map中</p><h2 id="Agent要搞清楚以下几个问题"><a href="#Agent要搞清楚以下几个问题" class="headerlink" title="Agent要搞清楚以下几个问题"></a>Agent要搞清楚以下几个问题</h2><ol><li>代理的类和执行main的类是一个classloader吗？<br>是的，用的是一个类加载器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_LOADER = <span class="keyword">new</span> </span><br><span class="line">AgentClassLoader(PluginBootstrap.class.getClassLoader());</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Instrumentation、ByteBubble、OpenTracing、Grpc</p></li><li><p>怎么知道拦截了哪些类</p></li><li><p>拦截了之后如何加强这些类</p></li><li><p><a href="https://blog.myimy.site/2019/03/01/%E9%87%87%E6%A0%B7%E7%8E%87/">采样率</a>是什么作用<br> 性能和采集效率的一个综合指标，采集率高了对客户端的CPU压力自然会上升，但是采集的数据多了，对业务使用自然是更好的。</p></li><li><p>一定要引入这么多插件的jar</p></li><li><p>怎么兼容不同版本的插件</p></li><li><p>Grpc传输和http传输的区别</p></li></ol><h2 id="次要问题："><a href="#次要问题：" class="headerlink" title="次要问题："></a>次要问题：</h2><ol><li>PluginDefine和AbstractClassEnhancePluginDefine有什么区别？</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html">Instrumentation介绍</a><br><a href="https://blog.csdn.net/fengyuzhengfan/article/details/38086743">class类简介</a><br><a href="https://www.jianshu.com/p/32d3e108f30a">SPI和ServiceLoader</a><br><a href="https://blog.csdn.net/github_35180164/article/details/52118286">公用API的安全狂街-自定义注解生命周期</a><br><a href="https://wu-sheng.gitbooks.io/opentracing-io/content/">openTracing文档</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-5things13/index.html">用 Maven 管理项目文件周期的技巧</a><br><a href="https://blog.csdn.net/belalds/article/details/83105685">深入理解Java ClassLoader及在 JavaAgent 中的应用</a><br><a href="https://juejin.im/post/5ac32eba5188255c313af0dd">基于Java Instrument的Agent实现</a><br><a href="http://www.hiwzc.com/post/f4997548.html">JAVA SPI详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 链路监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 链路监控 </tag>
            
            <tag> javaagent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务常见解决方案</title>
      <link href="/2019/03/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/03/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="Fescar"><a href="#Fescar" class="headerlink" title="Fescar"></a>Fescar</h2><p><a href="https://github.com/alibaba/fescar/">Fescar: Fast &amp; Easy Commit And Rollback</a><br><a href="http://os.51cto.com/art/201901/590738.htm">关于开源分布式事务中间件Fescar的提问</a><br><a href="https://www.jianshu.com/p/82b98f037034">FESCAR：阿里重磅开源分布式事务解决方案</a></p><a id="more"></a><h2 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h2><h2 id="基于消息的最终一致"><a href="#基于消息的最终一致" class="headerlink" title="基于消息的最终一致"></a>基于消息的最终一致</h2><h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><h2 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h2>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> todo </tag>
            
            <tag> JAVA </tag>
            
            <tag> RPC </tag>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch运维的思考</title>
      <link href="/2019/02/23/elastic/Elasticsearch%E8%BF%90%E7%BB%B4%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2019/02/23/elastic/Elasticsearch%E8%BF%90%E7%BB%B4%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="当前的情况"><a href="#当前的情况" class="headerlink" title="当前的情况"></a>当前的情况</h2><ul><li><p>当前每一个租户一共会创建95个索引。</p></li><li><p>分片的设置是：indexShardsNumber=2，indexReplicasNumber=0。</p></li><li><p>集群一共有四个节点，每一个节点有60G的空间。</p></li><li><p>目前线上共有6个租户，计算下来一共是1,140个分片</p></li></ul><a id="more"></a><h2 id="产生了哪些问题"><a href="#产生了哪些问题" class="headerlink" title="产生了哪些问题"></a>产生了哪些问题</h2><ul><li><p>副本数为0，没有备份，当主分区出现故障的时候，容错缺失。</p></li><li><p>分区数设置不合理，一般情况下分区数应该是节点数的1.5——3倍（因为es的分区数设置之后再调整很麻烦，所以评估好数据规模很重要），目前有4个节点，合理的分区数应该是6-18之间。</p></li><li><p>目前节点的容量以及数量很有可能跟不上业务的发展，如果大规模推广，存储机器的成本压力很大。</p></li></ul><h2 id="如何解决这些问题"><a href="#如何解决这些问题" class="headerlink" title="如何解决这些问题"></a>如何解决这些问题</h2><h3 id="1-预估集群大小"><a href="#1-预估集群大小" class="headerlink" title="1. 预估集群大小"></a>1. 预估集群大小</h3><p>索引吞吐量<br>文档大小<br>搜索吞吐量<br>查询类型<br>热点索引文档数量<br>保留策略<br>响应时间需求<br>SLA 级别  </p><h3 id="2-优化索引设计"><a href="#2-优化索引设计" class="headerlink" title="2. 优化索引设计"></a>2. 优化索引设计</h3><h3 id="3-扩大集群容量"><a href="#3-扩大集群容量" class="headerlink" title="3. 扩大集群容量"></a>3. 扩大集群容量</h3><ul><li><p>数据迁移</p><p>  步骤1：按照新需求，创建你需要分片的索引。<br>  步骤2：<a href="https://blog.csdn.net/u013613428/article/details/78227277">reindex迁移</a></p></li></ul><h2 id="解决了这些问题之后，带来的变化"><a href="#解决了这些问题之后，带来的变化" class="headerlink" title="解决了这些问题之后，带来的变化"></a>解决了这些问题之后，带来的变化</h2><h2 id="问题解决之后的思考"><a href="#问题解决之后的思考" class="headerlink" title="问题解决之后的思考"></a>问题解决之后的思考</h2><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://blog.csdn.net/alan_liuyue/article/details/79585345">Elasticsearch之如何合理分配索引分片</a><br><a href="https://cloud.tencent.com/developer/article/1361274">Elasticsearch最佳实践之分片使用优化</a><br><a href="http://www.cnblogs.com/richaaaard/p/5227477.html">深入理解Shard和Lucene Index</a><br><a href="https://www.infoq.cn/article/elasticsearch-performance-tuning-practice-at-ebay">ebay的Elasticsearch调优实践</a></p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> elasticsearch </tag>
            
            <tag> todo </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC与REST理解</title>
      <link href="/2019/02/18/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/RPC%E4%B8%8EREST/"/>
      <url>/2019/02/18/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/RPC%E4%B8%8EREST/</url>
      
        <content type="html"><![CDATA[<p>什么是采样率，采样率有什么作用？</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h3><p>简单地说, 也就是服务器如何向客户端提供服务.</p><p>常用的方法有:</p><ul><li>RPC 所谓的远程过程调用 (面向方法)</li><li>SOA 所谓的面向服务的架构(面向消息)</li><li>REST 所谓的 Representational state transfer (面向资源)</li></ul><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC是Remote Procedure Call的缩写，字面意思是远程过程调用。但是说白了就是从本地机器去执行服务器上的一个函数。所以说 RPC 指的是一类日常的操作，是个很宽泛的概念。</p><p>RPC的思想是把本地函数映射到API，也就是说一个API对应的是一个方法。比如本地有一个getAllUsers，远程也能通过某种约定的协议来调用这个getAllUsers。至于这个协议是Socket、是HTTP还是别的什么并不重要（gRPC就是基于Http2.0的RPC框架）。</p><p>RPC中的主体都是动作，是个动词。</p><p>RPC像调用本地方法一样调用远程方法，通信协议大多采用二进制方式</p><h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>REST是Representational State Transfer的缩写，翻译过来是表现层状态转换。如果一个架构符合<a href="https://blog.csdn.net/ruojingzhang/article/details/79443329">REST原则</a>，就称它为RESTful架构。</p><p>REST是一种架构风格，汲取了WWW的成功经验：无状态，以资源为中心，充分利用HTTP协议和URI协议，提供统一的接口定义，使得它作为一种设计Web服务的方法而变得流行。在某种意义上，通过强调URI和HTTP等早期Internet标准，REST是对大型应用程序服务器时代之前的Web方式的回归。</p><p>REST的主体都是资源，是名词。</p><p>REST通常是Http+json、Http+xml，常见的http api都可以称为Rest接口。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li>什么是资源呢？就是我们平常上网访问的一张图片、一个文档、一个视频等。这些资源我们通过URI来定位，也就是一个URI表示一个资源。</li><li>面向资源是什么意思？和面向动作比较优劣点在哪里？</li></ol><h2 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h2><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p>HTTP请求往往围绕资源，而RPC的请求往往围绕一个动作。</p><h3 id="调用协议"><a href="#调用协议" class="headerlink" title="调用协议"></a>调用协议</h3><p>接口调用通常包含两个部分，序列化和通信协议。</p><ul><li>常见的序列化协议包括Json、Xml、Hession、Protobuf、Thrift、Text、Bytes等；　　</li><li>通信比较流行的是HTTP、soap、websockect、TCP等。　</li></ul><h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><ul><li><p>RPC通常基于<a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html">TCP协议</a>实现，常用框架例如gRpc，Netty、Mina、Thrift。</p></li><li><p>RESTful是基于<a href="feng.com/blog/2016/08/http.html">HTTP</a>协议实现。</p></li><li><p>RPC和RESTful的差别很大程度上是使用<a href="https://www.jianshu.com/p/947a2673102a">HTTP和TCP协议的区别</a>。</p></li></ul><h4 id="序列化协议"><a href="#序列化协议" class="headerlink" title="序列化协议"></a>序列化协议</h4><ul><li><p>HTTP通常使用Json。</p></li><li><p>RPC通常是使用RPC框架，这些RPC框架采用的序列化协议比如Protobuf、Thrift性能都高于Json或者XML。</p></li><li><p><a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">几种序列化协议的比较</a></p></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>Http相对更规范，更标准，更通用，无论哪种语言都支持Http协议。</p></li><li><p>RPC服务则需要客户端接口与服务端保持一致（会带来一些耦合），服务端提供一个方法，客户端通过接口直接发起调用，业务开发人员仅需要关注业务方法的调用即可，不再关注网络传输的细节，在开发上更为高效。</p></li><li><p>通常在公司内部接口调用会选择RPC，简单高效。对外开放的API通常选择REST，标准规范通用。</p></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://www.cnblogs.com/mindsbook/archive/2009/11/17/web_service_RESTvsRPC.html">Web Service实践之REST vs RPC</a><br><a href="https://zhuanlan.zhihu.com/p/44096204">HTTP 请求和 JSON-RPC</a><br><a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">序列化和反序列化</a><br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">HTTP协议入门</a><br><a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html">TCP协议入门</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> JAVA </tag>
            
            <tag> RPC </tag>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何避免过多的ifelse</title>
      <link href="/2018/11/10/java%E5%9F%BA%E7%A1%80/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E7%9A%84ifelse/"/>
      <url>/2018/11/10/java%E5%9F%BA%E7%A1%80/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E7%9A%84ifelse/</url>
      
        <content type="html"><![CDATA[<p><strong>一般的if/else判断大多集中在以下三种情型</strong></p><ol><li>空值判断</li><li>业务判断</li><li>状态判断</li></ol><a id="more"></a><p><strong>处理方法</strong></p><ol><li>对控制判断的处理，可以把接口分为内接口和外接口，将空值判断都放在外接口，这样进入内接口的时候就不需要考虑空值判断。</li><li>利用多态，抽象出处理基类，对每一种业务类型，用专门的实现类来处理对应逻辑。<br> 这里会带来一个问题，暴露给用户的类就多了，因为需要根据不同的业务场景创建不同的业务实现类，这时解决的方法：<ol><li>再封装一层，将实现类的权限降低，只暴露给用户创建实现类的方法。</li><li>用工厂模式产生类。</li><li>用map将类型与类加载到map中，在使用时根据业务类型动态加载实现类。</li></ol></li></ol><p><strong>参考</strong><br><a href="https://mp.weixin.qq.com/s/aT2vH2H8biq3Fh0-lSjqOQ">减少该死的 if else 嵌套</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码整洁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码整洁 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式与事件监听器</title>
      <link href="/2018/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8/"/>
      <url>/2018/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>观察者模式和事件监听器的区别，以及各自的使用场景。</p><a id="more"></a><h2 id="观察者模式和发布-订阅模式"><a href="#观察者模式和发布-订阅模式" class="headerlink" title="观察者模式和发布-订阅模式"></a>观察者模式和发布-订阅模式</h2><p>参考 -&gt; <a href="https://juejin.im/post/5a14e9edf265da4312808d86">观察者模式 vs 发布-订阅模式</a></p><p>观察者模式和发布订阅模式最大的<code>区别</code>应该是，前者的Observer明确的知道Publisher，而后者，Publisher和Observer之间还有一个Coordinator，Publisher和Observer都不知道对方，只通过事件，由Coordinator实现消息的通信。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g16zdl3ykdj30sq0my76i.jpg" alt="观察者模式和发布订阅模式的区别"></p><p>两者都有松耦合的功效，在一个应用之中，通常是使用观察者模式。在跨系统或跨服务的场景下，通常是使用发布订阅模式。</p><p><a href="https://www.atatech.org//articles/136618/?flag_data_from=mail_daily_headline&amp;uid=446066">Java 9 的响应式编程</a></p><h2 id="监听器模式"><a href="#监听器模式" class="headerlink" title="监听器模式"></a>监听器模式</h2><p><a href="https://segmentfault.com/a/1190000013240470">监听器入门看这篇就够了</a></p><h2 id="事件监听器和观察者模式的异同"><a href="#事件监听器和观察者模式的异同" class="headerlink" title="事件监听器和观察者模式的异同"></a>事件监听器和观察者模式的异同</h2><p>参考 -&gt; <a href="https://my.oschina.net/u/923324/blog/792857">java设计模式-回调、事件监听器、观察者模式</a></p><h2 id="发布订阅模式在dubbo的应用"><a href="#发布订阅模式在dubbo的应用" class="headerlink" title="发布订阅模式在dubbo的应用"></a>发布订阅模式在dubbo的应用</h2><h3 id="dubbo的订阅和注册怎么实现的"><a href="#dubbo的订阅和注册怎么实现的" class="headerlink" title="dubbo的订阅和注册怎么实现的"></a>dubbo的订阅和注册怎么实现的</h3><p><a href="https://corsairmaster.github.io/2018/12/04/Dubbo%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Dubbo原理及其所涉及到的设计模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> todo </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2018/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式的优缺点"><a href="#代理模式的优缺点" class="headerlink" title="代理模式的优缺点"></a>代理模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>协调调用者和被调用者，降低了系统的耦合度</li><li>代理对象作为客户端和目标对象之间的中介，起到了保护目标对象的作用</li></ol><a id="more"></a><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>由于在客户端和真实主题之间增加了代理对象，因此会造成请求的处理速度变慢；</li><li>实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度。 </li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>其实就是针对优点的一些使用场景：</p><ol><li>因为安全原因需要屏蔽客户端直接访问对象。</li><li>在远程调用中需要使用代理类处理远程方法调用的技术细节 (如 <a href="https://blog.csdn.net/lmy86263/article/details/72594760">RMI</a>)。</li><li>为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。</li></ol><blockquote><ol><li>保护代理：控制目标对象的访问，给不同用户提供不同的访问权限 </li><li>智能引用代理，额外操作包括耗时操作、计算访问次数等等。目的：在不影响对象类的情况下，在访问对象时进行更多的操作。</li><li>虚拟代理：通过使用过一个小的对象代理一个大对象。</li><li>远程代理：为一个对象在不同的地址空间提供局部代表。</li><li>防火墙代理：保护目标不让恶意用户靠近。</li><li>Cache代理：为结果提供临时的存储空间，以便其他客户端调用。</li></ol></blockquote><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>在系统启动时，将消耗资源最多的方法都使用代理模式分离，可以加快系统的启动速度，减少用户的等待时间。而在用户真正做查询操作时再由代理类单独去加载真实的数据库查询类，完成用户的请求。这个过程就是使用代理模式实现了延迟加载。</p><p>如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它的原有的位置，只要在真正需要的时候才对它进行加载。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理的本质是，在运行时动态生成代理类，这是相对于静态代理而言的。静态代理会定义一个代理类（如ClientProxy.java），通过这个代理类来调用真实类。而动态代理没有这个代理类，只需要定义一些生成规则，代理类会在运行时动态生成。</p><p>动态代理类使用字节码动态生成加载技术，代理类的字节码将在运行时生成并载入当前代理的ClassLoader。生成动态代理类的方法很多，如JDK自带的动态处理、CGLIB、Javassist或者ASM库。</p><ul><li>JDK 的动态代理使用简单，它内置在 JDK 中，因此不需要引入第三方 Jar 包，但相对功能比较弱。</li><li>CGLIB 和 Javassist 都是高级的字节码生成库，总体性能比 JDK 自带的动态代理好，而且功能十分强大。</li><li>ASM 是低级的字节码生成工具，使用 ASM 已经近乎于在使用 Java bytecode 编程，对开发人员要求最高，当然，也是性能最好的一种动态代理生成工具。但 ASM 的使用很繁琐，而且性能也没有数量级的提升，与 CGLIB 等高级字节码生成工具相比，ASM 程序的维护性较差，如果不是在对性能有苛刻要求的场合，还是推荐 CGLIB 或者 Javassist。</li></ul><p>动态代理的一般处理流程：</p><ol><li>【生成代理类的字节码】根据指定的回调类生成动态代理类的字节码。</li><li>【生成代理类】将字节码装载到ClassLoader中，完成类的加载。</li><li>【生成代理类的实例】生成动态类的实例，并返回该实例。</li></ol><h4 id="jdk-proxy"><a href="#jdk-proxy" class="headerlink" title="jdk proxy"></a>jdk proxy</h4><blockquote><p>Demo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被代理的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDBQuery</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理接口的真实实现类</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBQuery</span> <span class="keyword">implements</span> <span class="title">IDBQuery</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"get db connection...begin"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">//假设数据库连接等耗时操作</span></span><br><span class="line">            log.info(<span class="string">"get db connection...end"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            log.error(ex.getLocalizedMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"request string"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负责代理类的生成</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBQueryJDKHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    IDBQuery realQuery = <span class="keyword">null</span>;<span class="comment">//定义主题接口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBQueryJDKHandler</span><span class="params">(IDBQuery query)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realQuery = query;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        log.info(<span class="string">"[DBQueryJDKHandler][invoke] method = "</span>, method.getName());</span><br><span class="line">        <span class="keyword">return</span> method.invoke(realQuery, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试jdk proxy代理类</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJdkProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IDBQuery idbProxy = (IDBQuery) Proxy.newProxyInstance(</span><br><span class="line">                ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> Class[]&#123;IDBQuery.class&#125;, <span class="keyword">new</span> DBQueryJDKHandler(<span class="keyword">new</span> DBQuery()));</span><br><span class="line"></span><br><span class="line">        idbProxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cglib-proxy"><a href="#cglib-proxy" class="headerlink" title="cglib proxy"></a>cglib proxy</h4><blockquote><p>Demo</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//被代理的真实类</span><br><span class="line">@Slf4j</span><br><span class="line">public class Hello &#123;</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        log.info(&quot;[Hello][sayHello]...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拦截真实类的方法以生成代理类</span><br><span class="line">@Slf4j</span><br><span class="line">public class HelloInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        log.info(&quot;[HelloInterceptor][intercept]...&quot;);</span><br><span class="line">        return proxy.invokeSuper(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//封装了下cglib代理类的生成代码</span><br><span class="line">public class HelloFactory &#123;</span><br><span class="line"></span><br><span class="line">    private static HelloFactory instance;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        instance = new HelloFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HelloFactory getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Hello create() &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        //指定回调类</span><br><span class="line">        enhancer.setCallback(new HelloInterceptor());</span><br><span class="line">        //指定真实类</span><br><span class="line">        enhancer.setSuperclass(Hello.class);</span><br><span class="line">        //生成代理类的实例</span><br><span class="line">        return (Hello) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试代理类的生成</span><br><span class="line">@Test</span><br><span class="line">public void testCglibProxy() &#123;</span><br><span class="line">    Hello hello = HelloFactory.getInstance().create();</span><br><span class="line">    hello.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jdk动态代理和cglib的比较"><a href="#jdk动态代理和cglib的比较" class="headerlink" title="jdk动态代理和cglib的比较"></a>jdk动态代理和cglib的比较</h4><table><thead><tr><th>功能\模块</th><th>jdk proxy</th><th>cglib</th></tr></thead><tbody><tr><td>指定回调类</td><td>实现InvocationHandler的自定义handler</td><td>拦截器，实现MethodInterceptor的自定义interceptor</td></tr><tr><td>类的装载</td><td>利用反射<br>InvocationHandler.invoke()</td><td>MethodInterceptor.intercept()</td></tr><tr><td>生成类的实例</td><td>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</td><td>反射 Enhancer enhancer = new Enhancer();<br>enhancer.setSuperclass(真实类);<br>enhancer.setCallback(回调处理类);<br>enhancer.create();</td></tr><tr><td>优点</td><td>实现比较简单，Java原生支持的，不需要任何外部依赖</td><td>通过继承的方式进行代理，无论目标对象有没有实现接口都可以代理</td></tr><tr><td>缺点</td><td>基于接口，如果对象没有实现接口就懵逼了</td><td>无法处理final的情况</td></tr><tr><td>效率</td><td>创建对象快</td><td>创建之后的对象运行快</td></tr></tbody></table><p>总结下：</p><ol><li>jdkproxy生成的动态类是java.lang.reflect.Proxy的子类，所有的JDK动态代理都会继承这个类。</li><li><p>cglib生成的动态类是真实类的子类。所以就涉及到final的问题。</p><ol><li>final类型不能有子类，所以CGLIB不能代理final类型。</li><li>final方法是不能重载的，所以也不能通过CGLIB代理，遇到这种情况不会抛异常，而是会跳过final方法只代理其他方法。</li></ol></li><li><p>cglib做了方法访问优化，使用建立方法索引的方式避免了传统Method的方法反射调用。</p></li></ol><h4 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h4><p>一个开源的分析、编辑和创建 Java 字节码的类库。直接操作class文件，可以修改class文件内容。性能较ASM 差，跟cglib差不多，但是使用简单。很多开源框架都在使用它。</p><p>优势：</p><ol><li>比反射开销小，性能高。</li><li>JAVAsist性能高于反射，低于ASM</li></ol><p>怎么用可以参考：<br><a href="https://segmentfault.com/a/1190000015654823">动态字节码操作-Javassist介绍</a><br><a href="https://www.jianshu.com/p/43424242846b">Javassist 使用指南（一）</a></p><h4 id="ByteBuddy"><a href="#ByteBuddy" class="headerlink" title="ByteBuddy"></a>ByteBuddy</h4><p>Byte Buddy 是直接对字节码编程的框架。当然在速度上会优于javassist。</p><p>Byte Buddy 的主要侧重点在于以最少的运行时生成代码。通常，类型创建或操作不是任何程序中的常见步骤，并不会对任何长期运行的应用程序产生重大影响；特别是因为类加载或类构建（class instrumentation）是运行此类代码时最耗时且不可避免的步骤。</p><p>具体的效率可以参见下表（从网上扣的图，没有实测过）<br><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g12az62dkkj31ja0gc0wy.jpg" alt></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>还有其他方式实现延迟加载吗？</li><li><p>为什么jdk proxy要基于接口实现？<br> 这是一种设计思路。jdk是面向接口的代理。<br> 对应JDK动态代理机制是<code>委托机制</code>，具体说动态实现接口类，在动态生成的实现类里面委托为hanlder去调用原始实现类方法。</p><p> 比如接口类为Abo,实现类为AboImpl,AboImpl的代理类为ProxyAoImpl ，那么ProxyAoImpl 能赋值给Abo?能够赋值给AboImpl？</p><p> ProxyAoImpl 是能够赋值给Abo的，因为前者间接实现了后者，但是ProxyAoImpl 不能赋值给AboImpl因为他们没有继承或者实现关系。所以回顾下自己项目中Rpc里面autowired时候都是对bo类进行的，而不是对boimpl，并且我们的boimpl类一般都是配置了事务切面被代理过的。</p><p> 对应Cglib则使用的<code>继承机制</code>，具体说被代理类和代理类是继承关系，所以代理类是可以赋值给被代理类的,如果被代理类有接口，那么代理类也可以赋值给接口。</p></li><li><p>jvm类加载的原理？</p></li><li>拦截器的实现原理？</li><li>监听器的实现原理？</li><li>Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑？</li><li>动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择？</li></ol><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/index.html">代理模式原理及实例讲解</a><br><a href="https://blog.csdn.net/carson_ho/article/details/54910472">代理模式（Proxy Pattern）- 最易懂的设计模式解析</a><br><a href="http://www.importnew.com/27772.html">Java Proxy 和 CGLIB 动态代理原理</a><br><a href="https://segmentfault.com/a/1190000014909002">Java反射机制及API使用</a><br><a href="https://blog.csdn.net/zghwaicsdn/article/details/50957474">CGLIB介绍与原理</a><br><a href="https://www.cnkirito.moe/rpc-dynamic-proxy/">深入理解RPC之动态代理篇</a><br><a href="https://zhuanlan.zhihu.com/p/28870960">Java JDK代理、CGLIB、AspectJ代理分析比较</a><br><a href="https://www.jianshu.com/p/3ea4a6b57f87">深入分析Java方法反射的实现原理</a><br><a href="https://notes.diguage.com/byte-buddy-tutorial/">Byte Buddy 教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> todo </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch的集群节点和分区</title>
      <link href="/2018/09/03/elastic/Elasticsearch%E7%9A%84%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%92%8C%E5%88%86%E5%8C%BA/"/>
      <url>/2018/09/03/elastic/Elasticsearch%E7%9A%84%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%92%8C%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>在存储方面，elasticsearch可以看作一个分布式数据库。<br>每一个节点可以看作是一个库，这些节点（分库）在集群内协同工作。一个索引可以看作是库里的表。</p><a id="more"></a><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>一个节点(node)就是一个Elasticsearch实例。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>一个集群(cluster)由一个或多个节点组成，它们具有相同<code>cluster.name</code>，它们协同工作，分享数据和负载。当加入新的节点或者删除一个节点时，集群就会感知到并平衡数据。</p><p>集群中一个节点会被选举为主节点(master)，它将临时管理集群级别的一些变更，例如<strong>新建或删除索引、增加或移除节点</strong>等。主节点不参与文档级别的变更或搜索，这意味着在流量增长的时候，该主节点不会成为集群的瓶颈。任何节点都可以成为主节点。</p><p>做为用户，我们能够与集群中的任何节点通信，包括主节点。每一个节点都知道文档存在于哪个节点上，它们可以转发请求到相应的节点上。我们访问的节点负责收集各节点返回的数据，最后一起返回给客户端。这一切都由Elasticsearch处理。</p><ul><li>主节点是否保存数据？</li><li>因为节点之间存在负载均衡，所以我们访问的节点可以是集群中的任意一个节点，当我们请求一个节点时，我们需要的文档不一定在该节点上，此时该节点负责收集各节点返回的数据。如果是这样的原理，那么确实要求每一个节点都知道文档的存放位置。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><p>为了将数据添加到Elasticsearch，我们需要索引(index)——一个存储关联数据的地方。实际上，索引只是一个用来指向一个或多个分片(shards)的“逻辑命名空间(logical namespace)”.</p><p>一个分片(shard)是一个最小级别“工作单元(worker unit)”,它只是保存了<strong>索引中所有数据的一部分</strong><a href="水平切分还是垂直切分？应该是垂直切分的，这样才有意义。"> ^如何切分</a>。我们的文档存储在分片中，并且在分片中被索引，但是我们的应用程序不会直接与它们通信，取而代之的是，直接与索引通信。</p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> elasticsearch </tag>
            
            <tag> todo </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch的分布式设计原理</title>
      <link href="/2018/09/01/elastic/Elasticsearch%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
      <url>/2018/09/01/elastic/Elasticsearch%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/61dd9fb7d785">ElasticSearch 如何保证数据一致性,实时性</a><br><a href="https://blog.csdn.net/wzdxt/article/details/50868031">为什么ES不适合做数据存储</a></p><p>Elastic主节点选举算法？？？</p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> elasticsearch </tag>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dapper的学习与思考</title>
      <link href="/2018/08/05/%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/Dapper%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%9D%E8%80%83/"/>
      <url>/2018/08/05/%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/Dapper%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="链路监控的设计目标"><a href="#链路监控的设计目标" class="headerlink" title="链路监控的设计目标"></a>链路监控的设计目标</h2><ol><li><p>低消耗</p><p> 在低消耗层面，Dapper提出采样率这个概念，用采样率来调节Agent的资源消耗。</p></li><li><p>应用级的透明</p><p> 无处不在的部署，应用级别的透明。</p></li><li><p>延展性</p></li></ol><a id="more"></a><p><strong>Q：采样率是什么？如何能够调节Agent的资源消耗。</strong><br><strong>Q：如何实现代码的无侵入，或者极低的侵入？</strong></p><h2 id="Dapper的分布式跟踪"><a href="#Dapper的分布式跟踪" class="headerlink" title="Dapper的分布式跟踪"></a>Dapper的分布式跟踪</h2><h3 id="跟踪树和调用链"><a href="#跟踪树和调用链" class="headerlink" title="跟踪树和调用链"></a>跟踪树和调用链</h3><blockquote><p>跟踪树</p></blockquote><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0kyg23o32j30jc0egwfm.jpg" alt="图1:跟踪树"></p><blockquote><p>调用链</p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0kyiq1353j30iu08dq40.jpg" alt="图2:图1中的某一个span"></p><p>调用链从字面上就很好理解，即一次完整的调用过程，可以看作是一条调用链路。<br>一条调用链上会有很多的节点（span）。在分布式环境下，这些节点这些节点可能有很多差异。</p><ol><li>跨技术架构，RPC、HTTP、MYSQL、MQ等等；</li><li>跨线程甚至跨主机，可能是在一个线程内，也可能是跨线程，甚至跨主机；</li><li>调用方式不同，可能是同步，也可能是异步。</li><li>跨语言，如JAVA、C、C++等</li></ol><p>所以，我们可以推断出，如果要画出一个链路，需要在span（节点）中需要记录哪些数据：</p><ol><li>TraceId 链路ID，记录节点和链路的关系；</li><li>spanId和spanName 节点的ID和NAME，标识本节点；</li><li>parentId 父节点的ID，标识节点间的层级关系；</li><li>times 节点消耗时间，这个我觉得是可选的。</li></ol><p><strong>Q：span的维度，即在什么情况下程序会创建一个新的span？<br>Q：节点的通信，即本节点怎么将自己的ID传递给下一个span以做为下一个节点的parentId？<br>A：见植入点章节</strong></p><h3 id="植入点"><a href="#植入点" class="headerlink" title="植入点"></a>植入点</h3><ol><li>同一个线程内的span，用ThreadLocal进行存储。</li><li>延迟调用或者异步调用，通过线程池或者其他执行器，在回调里存储这次跟踪的上下文，在回调函数被触发的时候，这次跟踪的上下文会与适当的线程关联上。</li><li>跨语言，google的技术架构中进程间通信几乎都是C++或者Java开发的RPC框架，Dapper做为google自用的监控工具，把跟踪植入了google的RPC框架（估计是<a href="https://www.infoq.cn/article/2015%2F03%2Fgrpc-google-http2-protobuf">gRPC</a>）里，非google的RPC框架估计目前还不支持。</li></ol><h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0kz0z9xklj30j30aaq3q.jpg" alt="图3:Dapper中注解的实现"></p><ol><li><p>通过加一个注解，将某个方法强制加入到链路中去，猜测是跟采样率有关，强行生成一个span？</p></li><li><p>用法</p><ol><li><p>添加简单文本文本</p><p> 像是自定义监控的功能。<br> 比如：下单的方法createOrder()上加注解@Annotation(“createOrder”)</p></li><li><p>添加key-value健值对</p><p> 这是官方文档的解释，Dapper也支持的key-value映射的 Annotation，提供给开发人员更强的跟踪能力，如持续的计数器，二进制消息记录和在一个进程上跑着的任意的用户数据。键值对的Annotation方式用来在分布式追踪的上下文中定义某个特定应用程序的相关类型。<br> @Annotation(“createOrder”,”1”)</p></li></ol></li><li><p>为了避免滥用的风险，每一个跟踪span有一个可配置的总Annotation量的上限。</p></li></ol><p><strong>Q：Annotation注解有什么作用？<br>A：估计要看Tracer.record这个方法做了什么事情…<br>Q：Annotation注解有哪些应用场景？<br>相当于是Dapper提供出来的API？注解应该只能加在方法上，不如直接调用Trace.record()方法来得方便，但是直接调用方法，会有滥用的风险。</strong></p><h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><h3 id="跟踪的收集"><a href="#跟踪的收集" class="headerlink" title="跟踪的收集"></a>跟踪的收集</h3><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0kzx9958oj30jg0d10uy.jpg" alt="图4:span数据的收集过程"></p><ol><li><p>首先，span数据写入（1）本地日志文件中【Agent】。 </p></li><li><p>然后Dapper的守护进程和收集组件把这些数据从生产环境的主机中拉出来（2）【Collector】。</p></li><li><p>最终写到（3）Dapper的Bigtable仓库中【Storage】。</p></li><li><p>监控数据可视化，Dapper提供API来访问Storage中的数据【Analysis &amp;&amp; UI】。</p></li></ol><p><strong>Q：日志文件打印在客户端，传输完之后即删除，还是日志文件到达一定大小的时候再删除？</strong></p><h3 id="带外数据跟踪收集"><a href="#带外数据跟踪收集" class="headerlink" title="带外数据跟踪收集"></a>带外数据跟踪收集</h3><p><strong>怎么理解带外数据（out-of-band）呢？</strong><br>out-of-band是通过其他的链路进行跟踪数据的收集，比如将span的跟踪数据写到日志里，由Daemon线程进行收集，这就是带外策略。与之相反的，in-band策略是把跟踪数据随着调用链传送下去。</p><p><strong>为什么要采用带外数据收集呢？</strong></p><ol><li><p>首先，如果采用带内收集方案，会影响应用程序网络动态。<br> 如果采用带内方案，跟踪数据势必要以RPC响应头的形式被返回，通常RPC回应小于10K，但是在Google里的许多规模较大的系统中，一次跟踪成千上万的span并不少见，在这种调用链路非常深的情况下，带内收集方案产生的跟踪数据会造成比较大的网络传输负担，整个跟踪的时间也会变得特别长，失去了数据的实时性。</p></li><li><p>其次，带内收集方案假定所有的RPC是完美嵌套的。我们发现，在所有的后端的系统返回的最终结果之前，有许多中间件会把结果返回给他们的调用者。带内收集系统是无法解释这种非嵌套的分布式执行模式的。</p></li></ol><h3 id="安全和隐私考虑"><a href="#安全和隐私考虑" class="headerlink" title="安全和隐私考虑"></a>安全和隐私考虑</h3><p>没看懂原文的这部分内容。</p><h2 id="Dapper部署状况"><a href="#Dapper部署状况" class="headerlink" title="Dapper部署状况"></a>Dapper部署状况</h2><h3 id="Dapper运行库"><a href="#Dapper运行库" class="headerlink" title="Dapper运行库"></a>Dapper运行库</h3><p>对基础RPC、线程控制和流程控制的组件库的植入。<br>包括span的创建，采样率的设置，以及把日志写入本地磁盘。</p><h3 id="生产环境下的涵盖面"><a href="#生产环境下的涵盖面" class="headerlink" title="生产环境下的涵盖面"></a>生产环境下的涵盖面</h3><ol><li>应用使用支持的组件库，支持无侵入开发的跟踪。</li><li>应用使用非标准的组件库，需要应该手动控制，或者将非标准的组件可以接入Dapper。</li><li>支持关闭Dapper跟踪。</li></ol><h3 id="跟踪Annotation的使用"><a href="#跟踪Annotation的使用" class="headerlink" title="跟踪Annotation的使用"></a>跟踪Annotation的使用</h3><p>感觉是自定义监控，将业务代码加入到监控中。</p><h2 id="处理跟踪损耗"><a href="#处理跟踪损耗" class="headerlink" title="处理跟踪损耗"></a>处理跟踪损耗</h2><p>跟踪系统的成本由两部分组成：</p><ol><li>正在被监控的系统在<code>生成</code>和<code>收集</code>追踪数据的消耗导致系统性能下降。</li><li>需要使用一部分资源来<code>存储</code>和<code>分析</code>跟踪数据。</li></ol><h3 id="生成跟踪的损耗"><a href="#生成跟踪的损耗" class="headerlink" title="生成跟踪的损耗"></a>生成跟踪的损耗</h3><p>生成跟踪的开销是Dapper性能影响中最关键的部分，因为收集和分析可以更容易在紧急情况下被关闭。</p><ol><li><p>创建和销毁span和annotation<br> 创建根span的消耗要大于其他span，原因是在创建根span的时候，需要生成整个链路的traceId。</p></li><li><p>记录到本地磁盘供后续的收集<br> 写入磁盘是最大的消耗，可以通过异步写入减少对应用系统的影响。但是在大流量的情况下，这部分的消耗还是需要重视。</p></li></ol><h3 id="收集跟踪的损耗"><a href="#收集跟踪的损耗" class="headerlink" title="收集跟踪的损耗"></a>收集跟踪的损耗</h3><ol><li><p>CPU使用率</p><ul><li>守护进程的单核cpu使用率很低，没超过0.3%</li><li>限制了Dapper守护进程为内核scheduler最低的优先级，防止发生CPU竞争</li></ul></li><li><p>带宽资源<br> Dapper的数据收集在Google的生产环境中的只占用了0.01%的网络资源</p></li></ol><h3 id="在生产环境下对负载的影响"><a href="#在生产环境下对负载的影响" class="headerlink" title="在生产环境下对负载的影响"></a>在生产环境下对负载的影响</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0l2sh2i7yj30jl09tab4.jpg" alt="图5:不同采样率对网络延迟和吞吐的影响"></p><p>（延迟和吞吐的实验误差分别是2.5%和0.15%）</p><p>我们看到，虽然对吞吐量的影响不是很明显，但为了避免明显的延迟，跟踪的采样还是必要的。然而，延迟和吞吐量的带来的损失在把采样率调整到小于1/16之后就全部在实验误差范围内。在实践中，我们发现即便采样率调整到1/1024仍然是有足够量的跟踪数据的用来跟踪大量的服务。保持Dapper的性能损耗基线在一个非常低的水平是很重要的，因为它为那些应用提供了一个宽松的环境使用完整的Annotation API而无惧性能损失。使用较低的采样率还有额外的好处，可以让持久化到硬盘中的跟踪数据在垃圾回收机制处理之前保留更长的时间，这样为Dapper的收集组件给了更多的灵活性。</p><h3 id="可变采样"><a href="#可变采样" class="headerlink" title="可变采样"></a>可变采样</h3><p>我们在部署可变采样的过程中，参数化配置采样率时，不是使用一个统一的采样方案，而是使用一个<code>采样期望率</code>来标识单位时间内采样的追踪。这样一来，低流量低负载自动提高采样率，而在高流量高负载的情况下会降低采样率，使损耗一直保持在控制之下。实际使用的采样率会随着跟踪本身记录下来，这有利于从Dapper的跟踪数据中准确的分析。</p><p><strong>Q：怎么实现这种可变采样的？<br>A：我们充分利用所有span都来自一个特定的跟踪并分享同一个跟踪ID这个事实，虽然这些span有可能横跨了数千个主机。对于在收集系统中的每一个span，我们用hash算法把跟踪ID转成一个标量Z，这里0&lt;=Z&lt;=1。如果Z比我们收集系统中的系数低的话，我们就保留这个span信息，并写入到Bigtable中。反之，我们就抛弃他。通过在采样决策中的跟踪ID，我们要么保存、要么抛弃整个跟踪，而不是单独处理跟踪内的span。我们发现，有了这个额外的配置参数使管理我们的收集管道变得简单多了，因为我们可以很容易地在配置文件中调整我们的全局写入率这个参数。</strong></p><h2 id="其他收获"><a href="#其他收获" class="headerlink" title="其他收获"></a>其他收获</h2><p>Dapper的不足：</p><ol><li><p>合并的影响：我们的模型隐含的前提是不同的子系统在处理的都是来自同一个被跟踪的请求。在某些情况下，缓冲一部分请求，然后一次性操作一个请求集会更加有效。（比如，磁盘上的一次合并写入操作）。在这种情况下，一个被跟踪的请求可以看似是一个大型工作单元。此外，<code>当有多个追踪请求被收集在一起，他们当中只有一个会用来生成那个唯一的跟踪ID，用来给其他span使用，所以就无法跟踪下去了</code>。我们正在考虑的解决方案，希望在可以识别这种情况的前提下，用尽可能少的记录来解决这个问题。</p></li><li><p>跟踪批处理负载：Dapper的设计，主要是针对在线服务系统，最初的目标是了解一个用户请求产生的系统行为。然而<code>离线的密集型负载例如符合MapReduce[10]模型的情况，也可以受益于性能挖潜</code>。在这种情况下，我们需要把跟踪ID与一些其他的有意义的工作单元做关联，诸如输入数据中的键值（或键值的范围），或是一个MapReduce shard。</p></li><li><p>寻找根源-与业务数据结合不紧密：Dapper可以有效地确定系统中的哪一部分致使系统整个速度变慢，但并不总是能够找出问题的根源。例如，一个请求很慢有可能不是因为它自己的行为，而是由于队列中其他排在它前面的(queued ahead of)请求还没处理完。程序可以使用应用级的annotation把队列的大小或过载情况写入跟踪系统。此外，如果这种情况屡见不鲜，那么在ProfileMe[11]中提到的成对的采样技术可以解决这个问题。它由两个时间重叠的采样率组成，并观察它们在整个系统中的相对延迟。</p></li><li><p>记录内核级的信息：一些内核可见的事件的详细信息有时对确定问题根源是很有用的。我们有一些工具，能够跟踪或以其他方式描述内核的执行，但是，想用通用的或是不那么突兀的方式，是很难把这些信息到捆绑到用户级别的跟踪上下文中。我们正在研究一种妥协的解决方案，我们在用户层面上把一些内核级的活动参数做快照，然后绑定他们到一个活动的span上。</p></li></ol><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol><li>ThreadLocal</li><li>线程池</li><li>RPC框架</li><li>自定义注解</li><li>Bigtable</li><li>MapReduce模型</li><li>采样率<br><br>参考<a href="https://segmentfault.com/a/1190000007370525">浅述APM采样与端到端</a></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://bigbully.github.io/Dapper-translation/">1. Dapper，大规模分布式系统的跟踪系统</a><br><a href="https://juejin.im/post/5a7a9e0af265da4e914b46f1#heading-9">2. 全链路监控（一）：方案概述与比较</a></p>]]></content>
      
      
      <categories>
          
          <category> 链路监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链路监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>采样率</title>
      <link href="/2018/08/01/%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/%E9%87%87%E6%A0%B7%E7%8E%87/"/>
      <url>/2018/08/01/%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/%E9%87%87%E6%A0%B7%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p>采样最直接的目的有两个：减少计算量和降低描述难度。</p><a id="more"></a><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0l49r7s3ij30k00mzwew.jpg" alt></p><p>在APM厂商中，普遍采用这样一种采样算法来计算Apdex（Application Performance Index）。</p><p>Apdex的计算公式是： Apdex ＝ ( 1 x 满意 ＋0.5 x 容忍 ＋ 0 x 失望 ) / 样本数。</p><p>我们套一下上面的公式： 假定样本为：小于2s的请求次数为10次，满意； 大于2s，小于8s的请求次数为20次，容忍；大于等于8s的请求次数为10次，失望。 那么得到 Apdex = ( 1 x 10 + 0.5 x 20 + 0 x 10 ) / 40 = 0.5 ，结果是Unacceptable 不能接受的，说明这次采样的这个系统就在GG 的边缘了。</p><p>但是Apdex公式的计算只是在一个<code>宏观上判断一个服务的综合状态</code>，如果细化的话，这个计算公式是一个加权的结果，如果有5个请求都是大于等于8s,但是其他35个都是小于2s的，那么得出的Apdex为0.875，已经是Good的状态了，但是如果这8s的5个请求是服务的主入口或者重要接口，那么这Good的表面价值就会带来巨大隐患，所以对于采样率的计算，需要对于宏观上有一套计算方案，也需要对于细节处进行探查。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/40623010">全链路分布式跟踪系统与APM</a><br><a href="https://segmentfault.com/a/1190000007370525">浅述APM采样与端到端</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 链路监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用指令</title>
      <link href="/2018/07/01/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/linux/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-1/"/>
      <url>/2018/07/01/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/linux/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-1/</url>
      
        <content type="html"><![CDATA[<h2 id="给目录设置用户和用户组"><a href="#给目录设置用户和用户组" class="headerlink" title="给目录设置用户和用户组"></a>给目录设置用户和用户组</h2><p><code>chown -R admin:admin admin/</code></p><a id="more"></a><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p>userdel [用户名]<br>删除某一个用户，eg：删除admin用户<code>userdel admin</code> </p><h2 id="修改账户密码"><a href="#修改账户密码" class="headerlink" title="修改账户密码"></a>修改账户密码</h2><p>passwd [账户名]<br>    修改某一个账户的密码，eg：修改admin的密码<code>passwd admin</code> </p><p>passwd<br>    修改root账户的密码</p><h2 id="新增账户"><a href="#新增账户" class="headerlink" title="新增账户"></a>新增账户</h2><p>adduser [用户名]<br>    创建用户密码和目录</p><p>useradd [用户名]<br>    只创建用户，不创建目录</p><h2 id="安装lsrz"><a href="#安装lsrz" class="headerlink" title="安装lsrz"></a>安装lsrz</h2><p>yum -y install lrzsz;</p><h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><h3 id="安装zip命令"><a href="#安装zip命令" class="headerlink" title="安装zip命令"></a>安装zip命令</h3><p>yum -y install unzip zip</p><h3 id="解压到指定目录"><a href="#解压到指定目录" class="headerlink" title="解压到指定目录"></a>解压到指定目录</h3><p>tar xvf filename.tar -C /specific dir</p><p>##给admin账号sudo权限<br>vi /etc/sudoers<br>admin    ALL=(ALL)       ALL</p><h2 id="修改别名"><a href="#修改别名" class="headerlink" title="修改别名"></a>修改别名</h2><p>vi ~/.bashrc<br>source ~/.bashrc</p><h2 id="查看目录树下各个文件的大小"><a href="#查看目录树下各个文件的大小" class="headerlink" title="查看目录树下各个文件的大小"></a>查看目录树下各个文件的大小</h2><p>du -m [文件目录]<br><code>-m</code> 表示以M为单位</p><h2 id="查看监听端口"><a href="#查看监听端口" class="headerlink" title="查看监听端口"></a>查看监听端口</h2><p>netstat -tulpn | grep LISTEN</p><h2 id="文件夹复制"><a href="#文件夹复制" class="headerlink" title="文件夹复制"></a>文件夹复制</h2><p>cp -r [source] [target]<br>将source文件夹下的内容复制到target文件夹下。<br><code>-r</code> 遍历文件夹下所有目录</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r /home/admin/kk-apm-web /home/admin/kk-apm/1.0.3/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下设置指令别名</title>
      <link href="/2018/06/20/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/mac/Mac%E4%B8%8B%E5%A2%9E%E5%8A%A0%E6%8C%87%E4%BB%A4%E5%88%AB%E5%90%8D-1/"/>
      <url>/2018/06/20/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/mac/Mac%E4%B8%8B%E5%A2%9E%E5%8A%A0%E6%8C%87%E4%BB%A4%E5%88%AB%E5%90%8D-1/</url>
      
        <content type="html"><![CDATA[<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>alias [别名]=’[指令名称]’</p><a id="more"></a><h2 id="临时有效（重启失效）"><a href="#临时有效（重启失效）" class="headerlink" title="临时有效（重启失效）"></a>临时有效（重启失效）</h2><ol><li>在命令行中输入别名指令，如：<code>alias ll=&#39;ls -alh</code></li></ol><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0t67tazupj30l801ut8w.jpg" alt="在mac终端控制台直接输入指令"></p><ol start="2"><li>取消的命令为：<code>unalias ll</code></li></ol><h2 id="永久生效"><a href="#永久生效" class="headerlink" title="永久生效"></a>永久生效</h2><ol><li><p>在bash_profile文件中<code>vim ~/.bash_profile</code>加入别名指令，如：<br> <img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0t65q2kzvj30kg09qgn2.jpg" alt="修改bash_profile文件"></p><blockquote><p>等号两边均无空格，指令名称中如有空格，需用引号包裹</p></blockquote></li><li><p>source ~/.bash_profile使其生效</p></li><li>也可以修改 /etc/profile文件，不过这个是全家配置脚本，修改了所有用户都会生效。</li></ol><h2 id="登录shell会话的启动文件"><a href="#登录shell会话的启动文件" class="headerlink" title="登录shell会话的启动文件"></a>登录shell会话的启动文件</h2><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td>/etc/profile</td><td>应用于所有用户的全局配置脚本</td></tr><tr><td>~/.bash_profile</td><td>用户私人的启动文件</td></tr><tr><td>~/.bash_login</td><td>如果~/.bash_profile没有找到，会尝试读取这个文件</td></tr><tr><td>~/.profile</td><td>如果~/.bash_profile和~/.bash_login没有找到，会尝试读取这个文件</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建个人博客</title>
      <link href="/2018/06/10/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/06/10/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>从零开始搭建一个个人博客系统记录。</p><a id="more"></a><h2 id="准备git"><a href="#准备git" class="headerlink" title="准备git"></a>准备git</h2><p>安装git，并将本地的公钥维护到github，这样可以免密提交代码【<a href="https://www.jianshu.com/p/7edb6b838a2e">MAC上Git安装与GitHub基本使用</a>】</p><ol><li>在本机安装git</li><li><p>设置user.name和user.email配置信息，加global是全局变量，也可以在单个项目目录里单独设置局部变量，去掉global即可。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure></li><li><p>生成本地ssh密钥文件，输入：<code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code></p></li><li>将本地生成的公钥维护到github里</li><li>测试是否成功，输入：<code>ssh git@github.com</code>，查看是否有返回。</li></ol><h2 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h2><p><a href="https://www.jianshu.com/p/3b30c4c846d1">在mac上安装node.js</a></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在本地创建文件夹，以存放hexo代码，以及博客文章。</p><ol><li><p>进入博客文件夹下，使用npm命令安装Hexo，输入：<code>npm install -g hexo-cli</code></p></li><li><p>安装完成后，初始化博客，输入：<code>hexo init blog</code></p></li><li><p>部署网站，绑定github的repositories<br> 在blog目录下，修改_config.yml文件。  </p><ul><li>type : git</li><li>repo : github pages托管的资源库地址+”.git”</li><li>branch : master</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repo: https://github.com/mayu1991/mayu1991.github.io.git</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure><ol start="4"><li>安装Git部署插件，在博客文件夹下，输入命令：<code>npm install hexo-deployer-git --save</code>，如果不执行这个命令，在hexo d的时候会报错。</li></ol><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><blockquote><p><a href="https://yanyinhong.github.io/2017/11/15/Resolve-npm-missing-write-access-problem/">Mac下安装npm全局包提示权限不够</a></p></blockquote><h2 id="启动Hexo"><a href="#启动Hexo" class="headerlink" title="启动Hexo"></a>启动Hexo</h2><ol><li>清除缓存 <code>hexo clean</code></li><li>启动服务预览 <code>hexo s</code> == <code>hexo server</code></li><li>部署到git <code>hexo d</code> == <code>hexo deploy</code><br><br> 这一步是将本地hexo编译后的js推送github代码库，然后利用github pages实现博客在公网发布。</li></ol><blockquote><p>hexo指令列表</p></blockquote><ul><li>新建文章 <code>hexo n &quot;我的博客&quot;</code> == <code>hexo new &quot;我的博客&quot;</code></li><li>清除缓存 <code>hexo clean</code></li><li>生成<code>hexo g</code> == <code>hexo generate</code></li><li>启动服务预览<code>hexo s</code> == <code>hexo server</code></li><li>部署<code>hexo d</code> == <code>hexo deploy</code></li></ul><h2 id="更换Hexo主题"><a href="#更换Hexo主题" class="headerlink" title="更换Hexo主题"></a>更换Hexo主题</h2><p><a href="https://hexo.io/themes/">Hexo主题库</a></p><p>我用了melody这个主题<br><a href="https://molunerfinn.com/">主题作者的博客</a><br><a href="https://github.com/Molunerfinn/hexo-theme-melody">git地址</a></p><p><strong>主题接入步骤</strong></p><ol><li><p>将主题下载到博客所在theme文件夹下</p><p> 路径：<code>/Users/mayu/Documents/blogs/blog/themes</code><br> 指令：<code>git clone -b master https://github.com/Molunerfinn/hexo-theme-melody</code></p></li><li><p>安装了一个插件<br> 指令：npm install hexo-renderer-jade hexo-renderer-stylus</p></li><li><p>按照<a href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html">接入文档</a>操作</p></li></ol><h2 id="调整博客设置"><a href="#调整博客设置" class="headerlink" title="调整博客设置"></a>调整博客设置</h2><ol><li>头像</li><li>标签</li><li>目录</li><li>相册</li><li>搜索</li><li><p><a href="https://molunerfinn.com/hexo-theme-melody-doc/#/zh-Hans/third-party-support?id=%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97uv%E5%92%8Cpv">访问日志</a></p></li><li><p>字数统计<br> 要为theme-melody配上字数统计特性, 你需要如下几个步骤:</p><ul><li><p>打开hexo工作目录</p><p><code>npm install hexo-wordcount --save</code>或者<code>yarn add hexo-wordcount</code></p></li><li><p>配置melody.yml:</p></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wordcount:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol><li>评论功能</li><li>集成 Baidu Analytics 和 Google Analytics</li><li>绑定域名</li></ol><h2 id="常用的工具"><a href="#常用的工具" class="headerlink" title="常用的工具"></a>常用的工具</h2><ol><li><a href="http://www.atool.org/colorpicker.php">在线颜色选择器</a></li><li><a href="https://toolinbox.net/iPic/">iPic图床-图片上传</a></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/26625249">1. GitHub+Hexo 搭建个人网站详细教程</a><br><a href="https://www.jianshu.com/p/834d7cc0668d">2. 我的博客是如何搭建的（github pages + HEXO + 域名绑定）</a><br><a href="https://molunerfinn.com/hexo-theme-melody-doc/#/zh-Hans/">3. melody主题博客接入文档</a><br><a href="http://ijiaober.github.io/categories/hexo/">4. hexo教程</a><br><a href="https://www.jianshu.com/p/3b30c4c846d1">5. 在mac上安装node.js</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
