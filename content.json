{"meta":{"title":"密斯特马的技术笔记","subtitle":"重拾初心 砥砺前行","description":null,"author":"manoo","url":"https://mayu1991.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-03-19T07:17:42.000Z","updated":"2019-03-19T07:17:51.674Z","comments":true,"path":"about/index.html","permalink":"https://mayu1991.github.io/about/index.html","excerpt":"","text":""},{"title":"文章目录","date":"2019-03-19T07:15:30.000Z","updated":"2019-03-19T08:03:07.000Z","comments":true,"path":"categories/index.html","permalink":"https://mayu1991.github.io/categories/index.html","excerpt":"","text":""},{"title":"文章标签","date":"2019-03-19T07:16:27.000Z","updated":"2019-03-19T08:03:09.696Z","comments":true,"path":"tags/index.html","permalink":"https://mayu1991.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"如何避免过多的ifelse","slug":"java基础/如何避免过多的ifelse","date":"2019-11-09T16:00:00.000Z","updated":"2019-03-19T08:28:16.659Z","comments":true,"path":"2019/11/10/java基础/如何避免过多的ifelse/","link":"","permalink":"https://mayu1991.github.io/2019/11/10/java基础/如何避免过多的ifelse/","excerpt":"一般的if/else判断大多集中在以下三种情型 空值判断 业务判断 状态判断","text":"一般的if/else判断大多集中在以下三种情型 空值判断 业务判断 状态判断 处理方法 对控制判断的处理，可以把接口分为内接口和外接口，将空值判断都放在外接口，这样进入内接口的时候就不需要考虑空值判断。 利用多态，抽象出处理基类，对每一种业务类型，用专门的实现类来处理对应逻辑。 这里会带来一个问题，暴露给用户的类就多了，因为需要根据不同的业务场景创建不同的业务实现类，这时解决的方法： 再封装一层，将实现类的权限降低，只暴露给用户创建实现类的方法。 用工厂模式产生类。 用map将类型与类加载到map中，在使用时根据业务类型动态加载实现类。 参考减少该死的 if else 嵌套","categories":[{"name":"代码整洁","slug":"代码整洁","permalink":"https://mayu1991.github.io/categories/代码整洁/"}],"tags":[{"name":"代码整洁","slug":"代码整洁","permalink":"https://mayu1991.github.io/tags/代码整洁/"},{"name":"JAVA","slug":"JAVA","permalink":"https://mayu1991.github.io/tags/JAVA/"}]},{"title":"自己动手写一个简单的探针（一）","slug":"链路监控/自己动手写一个简单的javaagent（一）","date":"2019-03-03T16:00:00.000Z","updated":"2019-03-19T08:08:09.151Z","comments":true,"path":"2019/03/04/链路监控/自己动手写一个简单的javaagent（一）/","link":"","permalink":"https://mayu1991.github.io/2019/03/04/链路监控/自己动手写一个简单的javaagent（一）/","excerpt":"需求 实现一个简单的javaagent。","text":"需求 实现一个简单的javaagent。 编码Step1 搭建agent的框架，实现动态加载 Premain.java 1234567public class Premain &#123; public static void premain(String agentArgs, Instrumentation inst) throws ClassNotFoundException, UnmodifiableClassException &#123; System.out.println(\"enter agent premain...\"); inst.addTransformer(new Transformer()); &#125;&#125; Transformer.java 1234567891011121314151617181920212223242526272829303132333435363738394041public class Transformer implements ClassFileTransformer &#123; private static final Set&lt;String&gt; classNameSet = new HashSet&lt;&gt;(); static &#123; classNameSet.add(\"com.example.demo.AgentTest\"); &#125; /** * 增强类 eg:静态注入监控代码 * * @param className 类名 * @return */ public byte[] enhanceMethod(String className) &#123; //增强代码 todo return new byte[0]; &#125; /** * 每加载一个类都会调用？ * * @param l * @param className * @param c * @param pd * @param b * @return * @throws IllegalClassFormatException */ public byte[] transform(ClassLoader l, String className, Class&lt;?&gt; c, ProtectionDomain pd, byte[] b) throws IllegalClassFormatException &#123; //判断当前的类是否需要转换 String currentClassName = className.replaceAll(\"/\", \".\"); if (!classNameSet.contains(currentClassName)) &#123; // 仅仅提升Set中含有的类 return null; &#125; //返回增强之后的类 return enhanceMethod(className); &#125;&#125; pom.xml 1234567891011121314151617&lt;build&gt; &lt;finalName&gt;myagent&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifestEntries&gt; &lt;Premain-Class&gt;com.manoo.agent.Premain&lt;/Premain-Class&gt; &lt;/manifestEntries&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 新建了一个springboot项目，在VM options里加上以下指令测试javaagent 1-javaagent:/Users/mayu/Documents/mycodes/myagent/target/myagent.jar 123456789@SpringBootApplicationpublic class TestagentApplication &#123; public static void main(String[] args) &#123; System.out.println(\"application main\"); SpringApplication.run(TestagentApplication.class, args); &#125;&#125; 启动之后发现程序有报错 12345678Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: com.manoo.agent.Premain at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:304) at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:401)FATAL ERROR in native method: processing of -javaagent failed 看了下myagent.jar包里是有这个类的，路径也没有问题。为什么会找不到这个类？ 猜测是类加载器的问题。于是研究了下javaagent的类加载原理，发现不是classloader的问题。 因为双亲类加载的原因，javaagent是无法获取应用程序的类，但是我这里是直接获取javaagent自己的类，所以不是classloader的问题。 ClassNotFoundException: 真的会使你的JVM慢下来吗？ 深入理解Java ClassLoader及在 JavaAgent 中的应用 将myagent.jar解压了一下，发现确实没有com.manoo.agent.Premain这个类，再看看发现我的classes类是在BOOT-INF/classes 路径下了。为了方便，我是直接用Spring boot创建的项目。用了spring-boot-maven-plugin打包，导致项目被打成了Spring boot的结构的jar包。 1234&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt; 后来一想如果javaagent用springboot，会不会有点太重了。目前这个javaagent功能还很简单，还不要使用框架。 于是把spring boot的依赖注释掉，重新编译了下myagent，拿到jar包之后解压了下，现在正常了。 Step2 实现被监控类的增强 判断哪些类需要被监控或者说被增强 怎么实现被监控类的增强 javassist byteBuddy（教程） 思考 代理模式 动态生成字节码的框架有哪些，效率如何？","categories":[{"name":"链路监控","slug":"链路监控","permalink":"https://mayu1991.github.io/categories/链路监控/"}],"tags":[{"name":"链路监控","slug":"链路监控","permalink":"https://mayu1991.github.io/tags/链路监控/"},{"name":"javaagent","slug":"javaagent","permalink":"https://mayu1991.github.io/tags/javaagent/"},{"name":"java","slug":"java","permalink":"https://mayu1991.github.io/tags/java/"}]},{"title":"自己动手写一个简单的探针(总纲)","slug":"链路监控/自己动手写一个简单的javaagent（总纲）","date":"2019-03-02T16:00:00.000Z","updated":"2019-03-19T09:15:44.638Z","comments":true,"path":"2019/03/03/链路监控/自己动手写一个简单的javaagent（总纲）/","link":"","permalink":"https://mayu1991.github.io/2019/03/03/链路监控/自己动手写一个简单的javaagent（总纲）/","excerpt":"需求 实现对当前容器系统参数（cpu，内存，网络）的收集，并将信息上传到服务端。 实现一个对代码无侵入的探针，只要应用程序启动了，就自行运转，无需应用程序进行改造。 实现agent的心跳检测。 实现根据采样率调节数据收集量。","text":"需求 实现对当前容器系统参数（cpu，内存，网络）的收集，并将信息上传到服务端。 实现一个对代码无侵入的探针，只要应用程序启动了，就自行运转，无需应用程序进行改造。 实现agent的心跳检测。 实现根据采样率调节数据收集量。 需求分析 怎么在代码无侵入的要求下运行监控程序？ 如果要做到无侵入，那么探针势必要与应用程序运行在一个进程里。如果探针单独部署，应用程序肯定是要做代码层面的改造与探针服务进行交互。 如何将探针的程序注入到应用程序里呢？利用 javaagent的Instrument。 怎么收集当前容器信息？ 用javaagent实现无侵入部署，在启动应用程序的同时，注入探针的代码，探针会启动一个定时器，由定时器来控制触发系统指标收集的任务。 同时再启动一个定时器，实现心跳机制。 为什么要做心跳？因为agent是单独部署在客户端的，服务端是开发者自己能够hold住的，客户端就有点鞭长莫及。所以需要用心跳来知晓agent的运行情况。 用什么方式上传到服务端？ 服务端数据结构怎么设计，用什么样的DB保存数据？ 如何实现采样率的动态调节？ 技术准备 利用instrument agent实现探针无侵入 Instrument “java.lang.instrument”包的具体实现，依赖于JVMTI。在Java SE 5 及其后续版本当中，开发者可以在一个普通 Java 程序（带有 main 函数的 Java 类）运行时，通过 - javaagent参数指定一个特定的jar文件来启动 Instrumentation的代理程序。 Instrumentation 的最大作用，就是类定义动态改变和操作。而且指令里也可以加上一些启动参数。 怎么获取启动参数？ JVMTI JVMTI全称 JVM Tool Interface，是 JVM 暴露出来的一些供用户扩展的接口集合。JVMTI 是基于事件驱动的，JVM 每执行到一定的逻辑就会调用一些事件的回调接口（如果有的话），这些接口可以供开发者扩展自己的逻辑。 JVMTIAgent 其实就是一个动态库，利用 JVMTI 暴露出来的一些接口来干一些我们想做、但是正常情况下又做不到的事情。 JVMTIAgent有三个回调函数，分别是： Agent_OnLoad，启动时加载。 Agent_OnAttach，运行时加载，这里还需要利用java的attach原理。 Agent_OnUnload，卸载时加载。 个人感觉这里应该用启动时加载，因为监控程序应该是7*24小时运行，必须与被监控应用相同的生命周期。如果是运行时加载，在什么样的节点启动监控也是很难定义。 利用Byte buddy实现了类的运行时动态加载和类的加强 启动流程 加载agent配置 加载agent插件 初始化agent服务管理 SPIJDK内置的一种服务提供发现机制 动态加载BootService接口的实现类 插件加载、匹配和拦截 agent插件体系 插件的加载 自定义的类加载器AgentClassLoader 注册 动态加载 插件的匹配 插件的拦截 指定需要拦截的类：在AgentBuilder.type处，这里可以指定需要拦截的类 指定需要拦截的方法：在builder.method处，这里可以指定需要拦截的方法 将需要拦截的类重新定义加载【ByteBuddy】 代码PluginFinder初始化方法：遍历所有pluginDefine，并获取classMatch，放到不同的map中 TIPS： 类的加载 类与对象的关系 创建一个对象的实例 Agent要搞清楚以下几个问题 代理的类和执行main的类是一个classloader吗？是的，用的是一个类加载器 12DEFAULT_LOADER = new AgentClassLoader(PluginBootstrap.class.getClassLoader()); Instrumentation、ByteBubble、OpenTracing、Grpc 怎么知道拦截了哪些类 拦截了之后如何加强这些类 采样率是什么作用 性能和采集效率的一个综合指标，采集率高了对客户端的CPU压力自然会上升，但是采集的数据多了，对业务使用自然是更好的。 一定要引入这么多插件的jar 怎么兼容不同版本的插件 Grpc传输和http传输的区别 次要问题： PluginDefine和AbstractClassEnhancePluginDefine有什么区别？ 参考Instrumentation介绍class类简介SPI和ServiceLoader公用API的安全狂街-自定义注解生命周期openTracing文档用 Maven 管理项目文件周期的技巧深入理解Java ClassLoader及在 JavaAgent 中的应用基于Java Instrument的Agent实现","categories":[{"name":"链路监控","slug":"链路监控","permalink":"https://mayu1991.github.io/categories/链路监控/"}],"tags":[{"name":"链路监控","slug":"链路监控","permalink":"https://mayu1991.github.io/tags/链路监控/"},{"name":"javaagent","slug":"javaagent","permalink":"https://mayu1991.github.io/tags/javaagent/"},{"name":"java","slug":"java","permalink":"https://mayu1991.github.io/tags/java/"}]},{"title":"分布式事务常见解决方案","slug":"分布式/事务/分布式事务常见解决方案","date":"2019-03-01T16:00:00.000Z","updated":"2019-03-19T08:13:39.593Z","comments":true,"path":"2019/03/02/分布式/事务/分布式事务常见解决方案/","link":"","permalink":"https://mayu1991.github.io/2019/03/02/分布式/事务/分布式事务常见解决方案/","excerpt":"FescarFescar: Fast &amp; Easy Commit And Rollback关于开源分布式事务中间件Fescar的提问FESCAR：阿里重磅开源分布式事务解决方案","text":"FescarFescar: Fast &amp; Easy Commit And Rollback关于开源分布式事务中间件Fescar的提问FESCAR：阿里重磅开源分布式事务解决方案 XA基于消息的最终一致TCCSaga","categories":[{"name":"分布式","slug":"分布式","permalink":"https://mayu1991.github.io/categories/分布式/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://mayu1991.github.io/tags/分布式/"},{"name":"todo","slug":"todo","permalink":"https://mayu1991.github.io/tags/todo/"},{"name":"JAVA","slug":"JAVA","permalink":"https://mayu1991.github.io/tags/JAVA/"},{"name":"RPC","slug":"RPC","permalink":"https://mayu1991.github.io/tags/RPC/"},{"name":"REST","slug":"REST","permalink":"https://mayu1991.github.io/tags/REST/"}]},{"title":"Elasticsearch运维的思考","slug":"elastic/Elasticsearch运维的思考","date":"2019-02-22T16:00:00.000Z","updated":"2019-03-19T08:11:32.599Z","comments":true,"path":"2019/02/23/elastic/Elasticsearch运维的思考/","link":"","permalink":"https://mayu1991.github.io/2019/02/23/elastic/Elasticsearch运维的思考/","excerpt":"当前的情况 当前每一个租户一共会创建95个索引。 分片的设置是：indexShardsNumber=2，indexReplicasNumber=0。 集群一共有四个节点，每一个节点有60G的空间。 目前线上共有6个租户，计算下来一共是1,140个分片","text":"当前的情况 当前每一个租户一共会创建95个索引。 分片的设置是：indexShardsNumber=2，indexReplicasNumber=0。 集群一共有四个节点，每一个节点有60G的空间。 目前线上共有6个租户，计算下来一共是1,140个分片 产生了哪些问题 副本数为0，没有备份，当主分区出现故障的时候，容错缺失。 分区数设置不合理，一般情况下分区数应该是节点数的1.5——3倍（因为es的分区数设置之后再调整很麻烦，所以评估好数据规模很重要），目前有4个节点，合理的分区数应该是6-18之间。 目前节点的容量以及数量很有可能跟不上业务的发展，如果大规模推广，存储机器的成本压力很大。 如何解决这些问题1. 预估集群大小索引吞吐量文档大小搜索吞吐量查询类型热点索引文档数量保留策略响应时间需求SLA 级别 2. 优化索引设计3. 扩大集群容量 数据迁移 步骤1：按照新需求，创建你需要分片的索引。 步骤2：reindex迁移 解决了这些问题之后，带来的变化问题解决之后的思考参考：Elasticsearch之如何合理分配索引分片Elasticsearch最佳实践之分片使用优化深入理解Shard和Lucene Indexebay的Elasticsearch调优实践","categories":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://mayu1991.github.io/categories/elasticsearch/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://mayu1991.github.io/tags/分布式/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://mayu1991.github.io/tags/elasticsearch/"},{"name":"todo","slug":"todo","permalink":"https://mayu1991.github.io/tags/todo/"},{"name":"运维","slug":"运维","permalink":"https://mayu1991.github.io/tags/运维/"}]},{"title":"RPC与REST理解","slug":"分布式/服务框架/RPC与REST","date":"2019-02-17T16:00:00.000Z","updated":"2019-03-19T08:14:57.424Z","comments":true,"path":"2019/02/18/分布式/服务框架/RPC与REST/","link":"","permalink":"https://mayu1991.github.io/2019/02/18/分布式/服务框架/RPC与REST/","excerpt":"什么是采样率，采样率有什么作用？","text":"什么是采样率，采样率有什么作用？ 基本概念Web Service简单地说, 也就是服务器如何向客户端提供服务. 常用的方法有: RPC 所谓的远程过程调用 (面向方法) SOA 所谓的面向服务的架构(面向消息) REST 所谓的 Representational state transfer (面向资源) RPCRPC是Remote Procedure Call的缩写，字面意思是远程过程调用。但是说白了就是从本地机器去执行服务器上的一个函数。所以说 RPC 指的是一类日常的操作，是个很宽泛的概念。 RPC的思想是把本地函数映射到API，也就是说一个API对应的是一个方法。比如本地有一个getAllUsers，远程也能通过某种约定的协议来调用这个getAllUsers。至于这个协议是Socket、是HTTP还是别的什么并不重要（gRPC就是基于Http2.0的RPC框架）。 RPC中的主体都是动作，是个动词。 RPC像调用本地方法一样调用远程方法，通信协议大多采用二进制方式 RESTREST是Representational State Transfer的缩写，翻译过来是表现层状态转换。如果一个架构符合REST原则，就称它为RESTful架构。 REST是一种架构风格，汲取了WWW的成功经验：无状态，以资源为中心，充分利用HTTP协议和URI协议，提供统一的接口定义，使得它作为一种设计Web服务的方法而变得流行。在某种意义上，通过强调URI和HTTP等早期Internet标准，REST是对大型应用程序服务器时代之前的Web方式的回归。 REST的主体都是资源，是名词。 REST通常是Http+json、Http+xml，常见的http api都可以称为Rest接口。 Q&amp;A 什么是资源呢？就是我们平常上网访问的一张图片、一个文档、一个视频等。这些资源我们通过URI来定位，也就是一个URI表示一个资源。 面向资源是什么意思？和面向动作比较优劣点在哪里？ 差异主体HTTP请求往往围绕资源，而RPC的请求往往围绕一个动作。 调用协议接口调用通常包含两个部分，序列化和通信协议。 常见的序列化协议包括Json、Xml、Hession、Protobuf、Thrift、Text、Bytes等； 通信比较流行的是HTTP、soap、websockect、TCP等。 通信协议 RPC通常基于TCP协议实现，常用框架例如gRpc，Netty、Mina、Thrift。 RESTful是基于HTTP协议实现。 RPC和RESTful的差别很大程度上是使用HTTP和TCP协议的区别。 序列化协议 HTTP通常使用Json。 RPC通常是使用RPC框架，这些RPC框架采用的序列化协议比如Protobuf、Thrift性能都高于Json或者XML。 几种序列化协议的比较 使用场景 Http相对更规范，更标准，更通用，无论哪种语言都支持Http协议。 RPC服务则需要客户端接口与服务端保持一致（会带来一些耦合），服务端提供一个方法，客户端通过接口直接发起调用，业务开发人员仅需要关注业务方法的调用即可，不再关注网络传输的细节，在开发上更为高效。 通常在公司内部接口调用会选择RPC，简单高效。对外开放的API通常选择REST，标准规范通用。 参考：Web Service实践之REST vs RPCHTTP 请求和 JSON-RPC序列化和反序列化HTTP协议入门TCP协议入门","categories":[{"name":"分布式","slug":"分布式","permalink":"https://mayu1991.github.io/categories/分布式/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://mayu1991.github.io/tags/分布式/"},{"name":"JAVA","slug":"JAVA","permalink":"https://mayu1991.github.io/tags/JAVA/"},{"name":"RPC","slug":"RPC","permalink":"https://mayu1991.github.io/tags/RPC/"},{"name":"REST","slug":"REST","permalink":"https://mayu1991.github.io/tags/REST/"}]},{"title":"观察者模式与事件监听器","slug":"设计模式/观察者模式与事件监听器","date":"2018-10-16T16:00:00.000Z","updated":"2019-03-19T08:27:43.375Z","comments":true,"path":"2018/10/17/设计模式/观察者模式与事件监听器/","link":"","permalink":"https://mayu1991.github.io/2018/10/17/设计模式/观察者模式与事件监听器/","excerpt":"观察者模式和事件监听器的区别，以及各自的使用场景。","text":"观察者模式和事件监听器的区别，以及各自的使用场景。 观察者模式和发布-订阅模式参考 -&gt; 观察者模式 vs 发布-订阅模式 观察者模式和发布订阅模式最大的区别应该是，前者的Observer明确的知道Publisher，而后者，Publisher和Observer之间还有一个Coordinator，Publisher和Observer都不知道对方，只通过事件，由Coordinator实现消息的通信。 两者都有松耦合的功效，在一个应用之中，通常是使用观察者模式。在跨系统或跨服务的场景下，通常是使用发布订阅模式。 监听器模式监听器入门看这篇就够了 事件监听器和观察者模式的异同参考 -&gt; java设计模式-回调、事件监听器、观察者模式 发布订阅模式在dubbo的应用dubbo的订阅和注册怎么实现的Dubbo原理及其所涉及到的设计模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://mayu1991.github.io/categories/设计模式/"}],"tags":[{"name":"todo","slug":"todo","permalink":"https://mayu1991.github.io/tags/todo/"},{"name":"设计模式","slug":"设计模式","permalink":"https://mayu1991.github.io/tags/设计模式/"}]},{"title":"代理模式","slug":"设计模式/代理模式","date":"2018-10-12T16:00:00.000Z","updated":"2019-03-19T08:27:33.129Z","comments":true,"path":"2018/10/13/设计模式/代理模式/","link":"","permalink":"https://mayu1991.github.io/2018/10/13/设计模式/代理模式/","excerpt":"代理模式的优缺点优点 协调调用者和被调用者，降低了系统的耦合度 代理对象作为客户端和目标对象之间的中介，起到了保护目标对象的作用","text":"代理模式的优缺点优点 协调调用者和被调用者，降低了系统的耦合度 代理对象作为客户端和目标对象之间的中介，起到了保护目标对象的作用 缺点 由于在客户端和真实主题之间增加了代理对象，因此会造成请求的处理速度变慢； 实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度。 使用场景其实就是针对优点的一些使用场景： 因为安全原因需要屏蔽客户端直接访问对象。 在远程调用中需要使用代理类处理远程方法调用的技术细节 (如 RMI)。 为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。 保护代理：控制目标对象的访问，给不同用户提供不同的访问权限 智能引用代理，额外操作包括耗时操作、计算访问次数等等。目的：在不影响对象类的情况下，在访问对象时进行更多的操作。 虚拟代理：通过使用过一个小的对象代理一个大对象。 远程代理：为一个对象在不同的地址空间提供局部代表。 防火墙代理：保护目标不让恶意用户靠近。 Cache代理：为结果提供临时的存储空间，以便其他客户端调用。 延迟加载在系统启动时，将消耗资源最多的方法都使用代理模式分离，可以加快系统的启动速度，减少用户的等待时间。而在用户真正做查询操作时再由代理类单独去加载真实的数据库查询类，完成用户的请求。这个过程就是使用代理模式实现了延迟加载。 如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它的原有的位置，只要在真正需要的时候才对它进行加载。 动态代理动态代理的本质是，在运行时动态生成代理类，这是相对于静态代理而言的。静态代理会定义一个代理类（如ClientProxy.java），通过这个代理类来调用真实类。而动态代理没有这个代理类，只需要定义一些生成规则，代理类会在运行时动态生成。 动态代理类使用字节码动态生成加载技术，代理类的字节码将在运行时生成并载入当前代理的ClassLoader。生成动态代理类的方法很多，如JDK自带的动态处理、CGLIB、Javassist或者ASM库。 JDK 的动态代理使用简单，它内置在 JDK 中，因此不需要引入第三方 Jar 包，但相对功能比较弱。 CGLIB 和 Javassist 都是高级的字节码生成库，总体性能比 JDK 自带的动态代理好，而且功能十分强大。 ASM 是低级的字节码生成工具，使用 ASM 已经近乎于在使用 Java bytecode 编程，对开发人员要求最高，当然，也是性能最好的一种动态代理生成工具。但 ASM 的使用很繁琐，而且性能也没有数量级的提升，与 CGLIB 等高级字节码生成工具相比，ASM 程序的维护性较差，如果不是在对性能有苛刻要求的场合，还是推荐 CGLIB 或者 Javassist。 动态代理的一般处理流程： 【生成代理类的字节码】根据指定的回调类生成动态代理类的字节码。 【生成代理类】将字节码装载到ClassLoader中，完成类的加载。 【生成代理类的实例】生成动态类的实例，并返回该实例。 jdk proxy Demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//被代理的接口public interface IDBQuery &#123; String request();&#125;//被代理接口的真实实现类@Slf4jpublic class DBQuery implements IDBQuery &#123; public DBQuery() &#123; try &#123; log.info(\"get db connection...begin\"); Thread.sleep(1000);//假设数据库连接等耗时操作 log.info(\"get db connection...end\"); &#125; catch (InterruptedException ex) &#123; log.error(ex.getLocalizedMessage()); &#125; &#125; @Override public String request() &#123; return \"request string\"; &#125;&#125;//负责代理类的生成@Slf4jpublic class DBQueryJDKHandler implements InvocationHandler &#123; IDBQuery realQuery = null;//定义主题接口 public DBQueryJDKHandler(IDBQuery query) &#123; this.realQuery = query; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log.info(\"[DBQueryJDKHandler][invoke] method = \", method.getName()); return method.invoke(realQuery, args); &#125;&#125;//测试jdk proxy代理类@RunWith(SpringRunner.class)public class ProxyTest &#123; @Test public void testJdkProxy() &#123; IDBQuery idbProxy = (IDBQuery) Proxy.newProxyInstance( ClassLoader.getSystemClassLoader(), new Class[]&#123;IDBQuery.class&#125;, new DBQueryJDKHandler(new DBQuery())); idbProxy.request(); &#125;&#125; cglib proxy Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//被代理的真实类@Slf4jpublic class Hello &#123; public void sayHello() &#123; log.info(&quot;[Hello][sayHello]...&quot;); &#125;&#125;//拦截真实类的方法以生成代理类@Slf4jpublic class HelloInterceptor implements MethodInterceptor &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; log.info(&quot;[HelloInterceptor][intercept]...&quot;); return proxy.invokeSuper(obj, args); &#125;&#125;//封装了下cglib代理类的生成代码public class HelloFactory &#123; private static HelloFactory instance; static &#123; instance = new HelloFactory(); &#125; public static HelloFactory getInstance() &#123; return instance; &#125; public Hello create() &#123; Enhancer enhancer = new Enhancer(); //指定回调类 enhancer.setCallback(new HelloInterceptor()); //指定真实类 enhancer.setSuperclass(Hello.class); //生成代理类的实例 return (Hello) enhancer.create(); &#125;&#125;//测试代理类的生成@Testpublic void testCglibProxy() &#123; Hello hello = HelloFactory.getInstance().create(); hello.sayHello();&#125; jdk动态代理和cglib的比较 功能\\模块 jdk proxy cglib 指定回调类 实现InvocationHandler的自定义handler 拦截器，实现MethodInterceptor的自定义interceptor 类的装载 利用反射InvocationHandler.invoke() MethodInterceptor.intercept() 生成类的实例 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 反射 Enhancer enhancer = new Enhancer();enhancer.setSuperclass(真实类);enhancer.setCallback(回调处理类);enhancer.create(); 优点 实现比较简单，Java原生支持的，不需要任何外部依赖 通过继承的方式进行代理，无论目标对象有没有实现接口都可以代理 缺点 基于接口，如果对象没有实现接口就懵逼了 无法处理final的情况 效率 创建对象快 创建之后的对象运行快 总结下： jdkproxy生成的动态类是java.lang.reflect.Proxy的子类，所有的JDK动态代理都会继承这个类。 cglib生成的动态类是真实类的子类。所以就涉及到final的问题。 final类型不能有子类，所以CGLIB不能代理final类型。 final方法是不能重载的，所以也不能通过CGLIB代理，遇到这种情况不会抛异常，而是会跳过final方法只代理其他方法。 cglib做了方法访问优化，使用建立方法索引的方式避免了传统Method的方法反射调用。 Javassist一个开源的分析、编辑和创建 Java 字节码的类库。直接操作class文件，可以修改class文件内容。性能较ASM 差，跟cglib差不多，但是使用简单。很多开源框架都在使用它。 优势： 比反射开销小，性能高。 JAVAsist性能高于反射，低于ASM 怎么用可以参考：动态字节码操作-Javassist介绍Javassist 使用指南（一） ByteBuddyByte Buddy 是直接对字节码编程的框架。当然在速度上会优于javassist。 Byte Buddy 的主要侧重点在于以最少的运行时生成代码。通常，类型创建或操作不是任何程序中的常见步骤，并不会对任何长期运行的应用程序产生重大影响；特别是因为类加载或类构建（class instrumentation）是运行此类代码时最耗时且不可避免的步骤。 具体的效率可以参见下表（从网上扣的图，没有实测过） 思考 还有其他方式实现延迟加载吗？ 为什么jdk proxy要基于接口实现？ 这是一种设计思路。jdk是面向接口的代理。 对应JDK动态代理机制是委托机制，具体说动态实现接口类，在动态生成的实现类里面委托为hanlder去调用原始实现类方法。 比如接口类为Abo,实现类为AboImpl,AboImpl的代理类为ProxyAoImpl ，那么ProxyAoImpl 能赋值给Abo?能够赋值给AboImpl？ ProxyAoImpl 是能够赋值给Abo的，因为前者间接实现了后者，但是ProxyAoImpl 不能赋值给AboImpl因为他们没有继承或者实现关系。所以回顾下自己项目中Rpc里面autowired时候都是对bo类进行的，而不是对boimpl，并且我们的boimpl类一般都是配置了事务切面被代理过的。 对应Cglib则使用的继承机制，具体说被代理类和代理类是继承关系，所以代理类是可以赋值给被代理类的,如果被代理类有接口，那么代理类也可以赋值给接口。 jvm类加载的原理？ 拦截器的实现原理？ 监听器的实现原理？ Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑？ 动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择？ 正向代理反向代理参考：代理模式原理及实例讲解代理模式（Proxy Pattern）- 最易懂的设计模式解析Java Proxy 和 CGLIB 动态代理原理Java反射机制及API使用CGLIB介绍与原理深入理解RPC之动态代理篇Java JDK代理、CGLIB、AspectJ代理分析比较深入分析Java方法反射的实现原理Byte Buddy 教程","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://mayu1991.github.io/categories/设计模式/"}],"tags":[{"name":"todo","slug":"todo","permalink":"https://mayu1991.github.io/tags/todo/"},{"name":"设计模式","slug":"设计模式","permalink":"https://mayu1991.github.io/tags/设计模式/"}]},{"title":"Elasticsearch的集群节点和分区","slug":"elastic/Elasticsearch的集群节点和分区","date":"2018-09-02T16:00:00.000Z","updated":"2019-03-19T08:26:36.335Z","comments":true,"path":"2018/09/03/elastic/Elasticsearch的集群节点和分区/","link":"","permalink":"https://mayu1991.github.io/2018/09/03/elastic/Elasticsearch的集群节点和分区/","excerpt":"在存储方面，elasticsearch可以看作一个分布式数据库。每一个节点可以看作是一个库，这些节点（分库）在集群内协同工作。一个索引可以看作是库里的表。","text":"在存储方面，elasticsearch可以看作一个分布式数据库。每一个节点可以看作是一个库，这些节点（分库）在集群内协同工作。一个索引可以看作是库里的表。 节点一个节点(node)就是一个Elasticsearch实例。 集群一个集群(cluster)由一个或多个节点组成，它们具有相同cluster.name，它们协同工作，分享数据和负载。当加入新的节点或者删除一个节点时，集群就会感知到并平衡数据。 集群中一个节点会被选举为主节点(master)，它将临时管理集群级别的一些变更，例如新建或删除索引、增加或移除节点等。主节点不参与文档级别的变更或搜索，这意味着在流量增长的时候，该主节点不会成为集群的瓶颈。任何节点都可以成为主节点。 做为用户，我们能够与集群中的任何节点通信，包括主节点。每一个节点都知道文档存在于哪个节点上，它们可以转发请求到相应的节点上。我们访问的节点负责收集各节点返回的数据，最后一起返回给客户端。这一切都由Elasticsearch处理。 主节点是否保存数据？ 因为节点之间存在负载均衡，所以我们访问的节点可以是集群中的任意一个节点，当我们请求一个节点时，我们需要的文档不一定在该节点上，此时该节点负责收集各节点返回的数据。如果是这样的原理，那么确实要求每一个节点都知道文档的存放位置。 索引添加索引为了将数据添加到Elasticsearch，我们需要索引(index)——一个存储关联数据的地方。实际上，索引只是一个用来指向一个或多个分片(shards)的“逻辑命名空间(logical namespace)”. 一个分片(shard)是一个最小级别“工作单元(worker unit)”,它只是保存了索引中所有数据的一部分 ^如何切分。我们的文档存储在分片中，并且在分片中被索引，但是我们的应用程序不会直接与它们通信，取而代之的是，直接与索引通信。","categories":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://mayu1991.github.io/categories/elasticsearch/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://mayu1991.github.io/tags/分布式/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://mayu1991.github.io/tags/elasticsearch/"},{"name":"todo","slug":"todo","permalink":"https://mayu1991.github.io/tags/todo/"},{"name":"索引","slug":"索引","permalink":"https://mayu1991.github.io/tags/索引/"}]},{"title":"Elasticsearch的分布式设计原理","slug":"elastic/Elasticsearch的分布式设计原理","date":"2018-08-31T16:00:00.000Z","updated":"2019-03-19T08:27:01.550Z","comments":true,"path":"2018/09/01/elastic/Elasticsearch的分布式设计原理/","link":"","permalink":"https://mayu1991.github.io/2018/09/01/elastic/Elasticsearch的分布式设计原理/","excerpt":"","text":"ElasticSearch 如何保证数据一致性,实时性为什么ES不适合做数据存储 Elastic主节点选举算法？？？","categories":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://mayu1991.github.io/categories/elasticsearch/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://mayu1991.github.io/tags/分布式/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://mayu1991.github.io/tags/elasticsearch/"},{"name":"todo","slug":"todo","permalink":"https://mayu1991.github.io/tags/todo/"}]},{"title":"Dapper的学习与思考","slug":"链路监控/Dapper的学习与思考","date":"2018-08-04T16:00:00.000Z","updated":"2019-03-19T08:26:12.496Z","comments":true,"path":"2018/08/05/链路监控/Dapper的学习与思考/","link":"","permalink":"https://mayu1991.github.io/2018/08/05/链路监控/Dapper的学习与思考/","excerpt":"链路监控的设计目标 低消耗 在低消耗层面，Dapper提出采样率这个概念，用采样率来调节Agent的资源消耗。 应用级的透明 无处不在的部署，应用级别的透明。 延展性","text":"链路监控的设计目标 低消耗 在低消耗层面，Dapper提出采样率这个概念，用采样率来调节Agent的资源消耗。 应用级的透明 无处不在的部署，应用级别的透明。 延展性 Q：采样率是什么？如何能够调节Agent的资源消耗。Q：如何实现代码的无侵入，或者极低的侵入？ Dapper的分布式跟踪跟踪树和调用链 跟踪树 调用链 调用链从字面上就很好理解，即一次完整的调用过程，可以看作是一条调用链路。一条调用链上会有很多的节点（span）。在分布式环境下，这些节点这些节点可能有很多差异。 跨技术架构，RPC、HTTP、MYSQL、MQ等等； 跨线程甚至跨主机，可能是在一个线程内，也可能是跨线程，甚至跨主机； 调用方式不同，可能是同步，也可能是异步。 跨语言，如JAVA、C、C++等 所以，我们可以推断出，如果要画出一个链路，需要在span（节点）中需要记录哪些数据： TraceId 链路ID，记录节点和链路的关系； spanId和spanName 节点的ID和NAME，标识本节点； parentId 父节点的ID，标识节点间的层级关系； times 节点消耗时间，这个我觉得是可选的。 Q：span的维度，即在什么情况下程序会创建一个新的span？Q：节点的通信，即本节点怎么将自己的ID传递给下一个span以做为下一个节点的parentId？A：见植入点章节 植入点 同一个线程内的span，用ThreadLocal进行存储。 延迟调用或者异步调用，通过线程池或者其他执行器，在回调里存储这次跟踪的上下文，在回调函数被触发的时候，这次跟踪的上下文会与适当的线程关联上。 跨语言，google的技术架构中进程间通信几乎都是C++或者Java开发的RPC框架，Dapper做为google自用的监控工具，把跟踪植入了google的RPC框架（估计是gRPC）里，非google的RPC框架估计目前还不支持。 Annotation 通过加一个注解，将某个方法强制加入到链路中去，猜测是跟采样率有关，强行生成一个span？ 用法 添加简单文本文本 像是自定义监控的功能。 比如：下单的方法createOrder()上加注解@Annotation(“createOrder”) 添加key-value健值对 这是官方文档的解释，Dapper也支持的key-value映射的 Annotation，提供给开发人员更强的跟踪能力，如持续的计数器，二进制消息记录和在一个进程上跑着的任意的用户数据。键值对的Annotation方式用来在分布式追踪的上下文中定义某个特定应用程序的相关类型。 @Annotation(“createOrder”,”1”) 为了避免滥用的风险，每一个跟踪span有一个可配置的总Annotation量的上限。 Q：Annotation注解有什么作用？A：估计要看Tracer.record这个方法做了什么事情…Q：Annotation注解有哪些应用场景？相当于是Dapper提供出来的API？注解应该只能加在方法上，不如直接调用Trace.record()方法来得方便，但是直接调用方法，会有滥用的风险。 采样率跟踪的收集 首先，span数据写入（1）本地日志文件中【Agent】。 然后Dapper的守护进程和收集组件把这些数据从生产环境的主机中拉出来（2）【Collector】。 最终写到（3）Dapper的Bigtable仓库中【Storage】。 监控数据可视化，Dapper提供API来访问Storage中的数据【Analysis &amp;&amp; UI】。 Q：日志文件打印在客户端，传输完之后即删除，还是日志文件到达一定大小的时候再删除？ 带外数据跟踪收集怎么理解带外数据（out-of-band）呢？out-of-band是通过其他的链路进行跟踪数据的收集，比如将span的跟踪数据写到日志里，由Daemon线程进行收集，这就是带外策略。与之相反的，in-band策略是把跟踪数据随着调用链传送下去。 为什么要采用带外数据收集呢？ 首先，如果采用带内收集方案，会影响应用程序网络动态。 如果采用带内方案，跟踪数据势必要以RPC响应头的形式被返回，通常RPC回应小于10K，但是在Google里的许多规模较大的系统中，一次跟踪成千上万的span并不少见，在这种调用链路非常深的情况下，带内收集方案产生的跟踪数据会造成比较大的网络传输负担，整个跟踪的时间也会变得特别长，失去了数据的实时性。 其次，带内收集方案假定所有的RPC是完美嵌套的。我们发现，在所有的后端的系统返回的最终结果之前，有许多中间件会把结果返回给他们的调用者。带内收集系统是无法解释这种非嵌套的分布式执行模式的。 安全和隐私考虑没看懂原文的这部分内容。 Dapper部署状况Dapper运行库对基础RPC、线程控制和流程控制的组件库的植入。包括span的创建，采样率的设置，以及把日志写入本地磁盘。 生产环境下的涵盖面 应用使用支持的组件库，支持无侵入开发的跟踪。 应用使用非标准的组件库，需要应该手动控制，或者将非标准的组件可以接入Dapper。 支持关闭Dapper跟踪。 跟踪Annotation的使用感觉是自定义监控，将业务代码加入到监控中。 处理跟踪损耗跟踪系统的成本由两部分组成： 正在被监控的系统在生成和收集追踪数据的消耗导致系统性能下降。 需要使用一部分资源来存储和分析跟踪数据。 生成跟踪的损耗生成跟踪的开销是Dapper性能影响中最关键的部分，因为收集和分析可以更容易在紧急情况下被关闭。 创建和销毁span和annotation 创建根span的消耗要大于其他span，原因是在创建根span的时候，需要生成整个链路的traceId。 记录到本地磁盘供后续的收集 写入磁盘是最大的消耗，可以通过异步写入减少对应用系统的影响。但是在大流量的情况下，这部分的消耗还是需要重视。 收集跟踪的损耗 CPU使用率 守护进程的单核cpu使用率很低，没超过0.3% 限制了Dapper守护进程为内核scheduler最低的优先级，防止发生CPU竞争 带宽资源 Dapper的数据收集在Google的生产环境中的只占用了0.01%的网络资源 在生产环境下对负载的影响 （延迟和吞吐的实验误差分别是2.5%和0.15%） 我们看到，虽然对吞吐量的影响不是很明显，但为了避免明显的延迟，跟踪的采样还是必要的。然而，延迟和吞吐量的带来的损失在把采样率调整到小于1/16之后就全部在实验误差范围内。在实践中，我们发现即便采样率调整到1/1024仍然是有足够量的跟踪数据的用来跟踪大量的服务。保持Dapper的性能损耗基线在一个非常低的水平是很重要的，因为它为那些应用提供了一个宽松的环境使用完整的Annotation API而无惧性能损失。使用较低的采样率还有额外的好处，可以让持久化到硬盘中的跟踪数据在垃圾回收机制处理之前保留更长的时间，这样为Dapper的收集组件给了更多的灵活性。 可变采样我们在部署可变采样的过程中，参数化配置采样率时，不是使用一个统一的采样方案，而是使用一个采样期望率来标识单位时间内采样的追踪。这样一来，低流量低负载自动提高采样率，而在高流量高负载的情况下会降低采样率，使损耗一直保持在控制之下。实际使用的采样率会随着跟踪本身记录下来，这有利于从Dapper的跟踪数据中准确的分析。 Q：怎么实现这种可变采样的？A：我们充分利用所有span都来自一个特定的跟踪并分享同一个跟踪ID这个事实，虽然这些span有可能横跨了数千个主机。对于在收集系统中的每一个span，我们用hash算法把跟踪ID转成一个标量Z，这里0&lt;=Z&lt;=1。如果Z比我们收集系统中的系数低的话，我们就保留这个span信息，并写入到Bigtable中。反之，我们就抛弃他。通过在采样决策中的跟踪ID，我们要么保存、要么抛弃整个跟踪，而不是单独处理跟踪内的span。我们发现，有了这个额外的配置参数使管理我们的收集管道变得简单多了，因为我们可以很容易地在配置文件中调整我们的全局写入率这个参数。 其他收获Dapper的不足： 合并的影响：我们的模型隐含的前提是不同的子系统在处理的都是来自同一个被跟踪的请求。在某些情况下，缓冲一部分请求，然后一次性操作一个请求集会更加有效。（比如，磁盘上的一次合并写入操作）。在这种情况下，一个被跟踪的请求可以看似是一个大型工作单元。此外，当有多个追踪请求被收集在一起，他们当中只有一个会用来生成那个唯一的跟踪ID，用来给其他span使用，所以就无法跟踪下去了。我们正在考虑的解决方案，希望在可以识别这种情况的前提下，用尽可能少的记录来解决这个问题。 跟踪批处理负载：Dapper的设计，主要是针对在线服务系统，最初的目标是了解一个用户请求产生的系统行为。然而离线的密集型负载例如符合MapReduce[10]模型的情况，也可以受益于性能挖潜。在这种情况下，我们需要把跟踪ID与一些其他的有意义的工作单元做关联，诸如输入数据中的键值（或键值的范围），或是一个MapReduce shard。 寻找根源-与业务数据结合不紧密：Dapper可以有效地确定系统中的哪一部分致使系统整个速度变慢，但并不总是能够找出问题的根源。例如，一个请求很慢有可能不是因为它自己的行为，而是由于队列中其他排在它前面的(queued ahead of)请求还没处理完。程序可以使用应用级的annotation把队列的大小或过载情况写入跟踪系统。此外，如果这种情况屡见不鲜，那么在ProfileMe[11]中提到的成对的采样技术可以解决这个问题。它由两个时间重叠的采样率组成，并观察它们在整个系统中的相对延迟。 记录内核级的信息：一些内核可见的事件的详细信息有时对确定问题根源是很有用的。我们有一些工具，能够跟踪或以其他方式描述内核的执行，但是，想用通用的或是不那么突兀的方式，是很难把这些信息到捆绑到用户级别的跟踪上下文中。我们正在研究一种妥协的解决方案，我们在用户层面上把一些内核级的活动参数做快照，然后绑定他们到一个活动的span上。 知识点 ThreadLocal 线程池 RPC框架 自定义注解 Bigtable MapReduce模型 采样率参考浅述APM采样与端到端 参考1. Dapper，大规模分布式系统的跟踪系统2. 全链路监控（一）：方案概述与比较","categories":[{"name":"链路监控","slug":"链路监控","permalink":"https://mayu1991.github.io/categories/链路监控/"}],"tags":[{"name":"链路监控","slug":"链路监控","permalink":"https://mayu1991.github.io/tags/链路监控/"}]},{"title":"采样率","slug":"链路监控/采样率","date":"2018-07-31T16:00:00.000Z","updated":"2019-03-19T08:26:00.240Z","comments":true,"path":"2018/08/01/链路监控/采样率/","link":"","permalink":"https://mayu1991.github.io/2018/08/01/链路监控/采样率/","excerpt":"采样最直接的目的有两个：减少计算量和降低描述难度。","text":"采样最直接的目的有两个：减少计算量和降低描述难度。 在APM厂商中，普遍采用这样一种采样算法来计算Apdex（Application Performance Index）。 Apdex的计算公式是： Apdex ＝ ( 1 x 满意 ＋0.5 x 容忍 ＋ 0 x 失望 ) / 样本数。 我们套一下上面的公式： 假定样本为：小于2s的请求次数为10次，满意； 大于2s，小于8s的请求次数为20次，容忍；大于等于8s的请求次数为10次，失望。 那么得到 Apdex = ( 1 x 10 + 0.5 x 20 + 0 x 10 ) / 40 = 0.5 ，结果是Unacceptable 不能接受的，说明这次采样的这个系统就在GG 的边缘了。 但是Apdex公式的计算只是在一个宏观上判断一个服务的综合状态，如果细化的话，这个计算公式是一个加权的结果，如果有5个请求都是大于等于8s,但是其他35个都是小于2s的，那么得出的Apdex为0.875，已经是Good的状态了，但是如果这8s的5个请求是服务的主入口或者重要接口，那么这Good的表面价值就会带来巨大隐患，所以对于采样率的计算，需要对于宏观上有一套计算方案，也需要对于细节处进行探查。 参考全链路分布式跟踪系统与APM浅述APM采样与端到端","categories":[{"name":"分布式","slug":"分布式","permalink":"https://mayu1991.github.io/categories/分布式/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://mayu1991.github.io/tags/分布式/"},{"name":"链路监控","slug":"链路监控","permalink":"https://mayu1991.github.io/tags/链路监控/"}]},{"title":"Linux常用指令","slug":"常用操作/linux/Linux常用指令-1","date":"2018-06-30T16:00:00.000Z","updated":"2019-03-19T08:09:33.852Z","comments":true,"path":"2018/07/01/常用操作/linux/Linux常用指令-1/","link":"","permalink":"https://mayu1991.github.io/2018/07/01/常用操作/linux/Linux常用指令-1/","excerpt":"给目录设置用户和用户组chown -R admin:admin admin/","text":"给目录设置用户和用户组chown -R admin:admin admin/ 删除用户userdel [用户名]删除某一个用户，eg：删除admin用户userdel admin 修改账户密码passwd [账户名] 修改某一个账户的密码，eg：修改admin的密码passwd admin passwd 修改root账户的密码 新增账户adduser [用户名] 创建用户密码和目录 useradd [用户名] 只创建用户，不创建目录 安装lsrzyum -y install lrzsz; 压缩和解压安装zip命令yum -y install unzip zip 解压到指定目录tar xvf filename.tar -C /specific dir ##给admin账号sudo权限vi /etc/sudoersadmin ALL=(ALL) ALL 修改别名vi ~/.bashrcsource ~/.bashrc 查看目录树下各个文件的大小du -m [文件目录]-m 表示以M为单位 查看监听端口netstat -tulpn | grep LISTEN 文件夹复制cp -r [source] [target]将source文件夹下的内容复制到target文件夹下。-r 遍历文件夹下所有目录 eg: 1cp -r /home/admin/kk-apm-web /home/admin/kk-apm/1.0.3/","categories":[{"name":"Linux","slug":"Linux","permalink":"https://mayu1991.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://mayu1991.github.io/tags/Linux/"}]},{"title":"Mac下设置指令别名","slug":"常用操作/mac/Mac下增加指令别名-1","date":"2018-06-19T16:00:00.000Z","updated":"2019-03-19T08:11:48.871Z","comments":true,"path":"2018/06/20/常用操作/mac/Mac下增加指令别名-1/","link":"","permalink":"https://mayu1991.github.io/2018/06/20/常用操作/mac/Mac下增加指令别名-1/","excerpt":"指令alias [别名]=’[指令名称]’","text":"指令alias [别名]=’[指令名称]’ 临时有效（重启失效） 在命令行中输入别名指令，如：alias ll=&#39;ls -alh 取消的命令为：unalias ll 永久生效 在bash_profile文件中vim ~/.bash_profile加入别名指令，如： 等号两边均无空格，指令名称中如有空格，需用引号包裹 source ~/.bash_profile使其生效 也可以修改 /etc/profile文件，不过这个是全家配置脚本，修改了所有用户都会生效。 登录shell会话的启动文件 文件 内容 /etc/profile 应用于所有用户的全局配置脚本 ~/.bash_profile 用户私人的启动文件 ~/.bash_login 如果~/.bash_profile没有找到，会尝试读取这个文件 ~/.profile 如果~/.bash_profile和~/.bash_login没有找到，会尝试读取这个文件","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://mayu1991.github.io/categories/博客搭建/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://mayu1991.github.io/tags/博客搭建/"}]},{"title":"从零开始搭建个人博客","slug":"常用操作/博客搭建/从零搭建个人博客","date":"2018-06-09T16:00:00.000Z","updated":"2019-03-19T08:09:10.301Z","comments":true,"path":"2018/06/10/常用操作/博客搭建/从零搭建个人博客/","link":"","permalink":"https://mayu1991.github.io/2018/06/10/常用操作/博客搭建/从零搭建个人博客/","excerpt":"从零开始搭建一个个人博客系统记录。","text":"从零开始搭建一个个人博客系统记录。 准备git安装git，并将本地的公钥维护到github，这样可以免密提交代码【MAC上Git安装与GitHub基本使用】 在本机安装git 设置user.name和user.email配置信息，加global是全局变量，也可以在单个项目目录里单独设置局部变量，去掉global即可。 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成本地ssh密钥文件，输入：ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 将本地生成的公钥维护到github里 测试是否成功，输入：ssh git@github.com如果是下面图片的样子就是成功了 安装node在mac上安装node.js 安装Hexo在本地创建文件夹，以存放hexo代码，以及博客文章。 进入博客文件夹下，使用npm命令安装Hexo，输入：npm install -g hexo-cli 安装完成后，初始化博客，输入：hexo init blog 部署网站，绑定github的repositories 在blog目录下，修改_config.yml文件。 type : git repo : github pages托管的资源库地址+”.git” branch : master 1234deploy: type: git repo: https://github.com/mayu1991/mayu1991.github.io.git branch: master 安装Git部署插件，在博客文件夹下，输入命令：npm install hexo-deployer-git --save，如果不执行这个命令，在hexo d的时候会报错。 Q&amp;A Mac下安装npm全局包提示权限不够 启动Hexo 清除缓存 hexo clean 启动服务预览 hexo s == hexo server 部署到git hexo d == hexo deploy 这一步是将本地hexo编译后的js推送github代码库，然后利用github pages实现博客在公网发布。 hexo指令列表 新建文章 hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; 清除缓存 hexo clean 生成hexo g == hexo generate 启动服务预览hexo s == hexo server 部署hexo d == hexo deploy 更换Hexo主题Hexo主题库 我用了melody这个主题主题作者的博客git地址 主题接入步骤 将主题下载到博客所在theme文件夹下 路径：/Users/mayu/Documents/blogs/blog/themes 指令：git clone -b master https://github.com/Molunerfinn/hexo-theme-melody 安装了一个插件 指令：npm install hexo-renderer-jade hexo-renderer-stylus 按照接入文档操作 调整博客设置 头像 标签 目录 相册 搜索 访问日志 字数统计 要为theme-melody配上字数统计特性, 你需要如下几个步骤: 打开hexo工作目录 npm install hexo-wordcount --save或者yarn add hexo-wordcount 配置melody.yml: 12wordcount: enable: true TODO 评论功能 集成 Baidu Analytics 和 Google Analytics 绑定域名 常用的工具 在线颜色选择器 iPic图床-图片上传 参考文章1. GitHub+Hexo 搭建个人网站详细教程2. 我的博客是如何搭建的（github pages + HEXO + 域名绑定）3. melody主题博客接入文档4. hexo教程5. 在mac上安装node.js","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://mayu1991.github.io/categories/博客搭建/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://mayu1991.github.io/tags/博客搭建/"}]}]}